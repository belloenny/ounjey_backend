// Code generated by Prisma (prisma@1.34.8). DO NOT EDIT.
// Please don't change this file manually but run `prisma generate` to update it.
// For more information, please read the docs: https://www.prisma.io/docs/prisma-client/

import { DocumentNode } from "graphql";
import {
  makePrismaClientClass,
  BaseClientOptions,
  Model
} from "prisma-client-lib";
import { typeDefs } from "./prisma-schema";

export type AtLeastOne<T, U = { [K in keyof T]: Pick<T, K> }> = Partial<T> &
  U[keyof U];

export type Maybe<T> = T | undefined | null;

export interface Exists {
  booking: (where?: BookingWhereInput) => Promise<boolean>;
  listing: (where?: ListingWhereInput) => Promise<boolean>;
  location: (where?: LocationWhereInput) => Promise<boolean>;
  payment: (where?: PaymentWhereInput) => Promise<boolean>;
  paymentAccount: (where?: PaymentAccountWhereInput) => Promise<boolean>;
  picture: (where?: PictureWhereInput) => Promise<boolean>;
  review: (where?: ReviewWhereInput) => Promise<boolean>;
  user: (where?: UserWhereInput) => Promise<boolean>;
  vendor: (where?: VendorWhereInput) => Promise<boolean>;
  views: (where?: ViewsWhereInput) => Promise<boolean>;
  savedList: (where?: savedListWhereInput) => Promise<boolean>;
}

export interface Node {}

export type FragmentableArray<T> = Promise<Array<T>> & Fragmentable;

export interface Fragmentable {
  $fragment<T>(fragment: string | DocumentNode): Promise<T>;
}

export interface Prisma {
  $exists: Exists;
  $graphql: <T = any>(
    query: string,
    variables?: { [key: string]: any }
  ) => Promise<T>;

  /**
   * Queries
   */

  booking: (where: BookingWhereUniqueInput) => BookingNullablePromise;
  bookings: (args?: {
    where?: BookingWhereInput;
    orderBy?: BookingOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Booking>;
  bookingsConnection: (args?: {
    where?: BookingWhereInput;
    orderBy?: BookingOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => BookingConnectionPromise;
  listing: (where: ListingWhereUniqueInput) => ListingNullablePromise;
  listings: (args?: {
    where?: ListingWhereInput;
    orderBy?: ListingOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Listing>;
  listingsConnection: (args?: {
    where?: ListingWhereInput;
    orderBy?: ListingOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => ListingConnectionPromise;
  location: (where: LocationWhereUniqueInput) => LocationNullablePromise;
  locations: (args?: {
    where?: LocationWhereInput;
    orderBy?: LocationOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Location>;
  locationsConnection: (args?: {
    where?: LocationWhereInput;
    orderBy?: LocationOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => LocationConnectionPromise;
  payment: (where: PaymentWhereUniqueInput) => PaymentNullablePromise;
  payments: (args?: {
    where?: PaymentWhereInput;
    orderBy?: PaymentOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Payment>;
  paymentsConnection: (args?: {
    where?: PaymentWhereInput;
    orderBy?: PaymentOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => PaymentConnectionPromise;
  paymentAccount: (
    where: PaymentAccountWhereUniqueInput
  ) => PaymentAccountNullablePromise;
  paymentAccounts: (args?: {
    where?: PaymentAccountWhereInput;
    orderBy?: PaymentAccountOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<PaymentAccount>;
  paymentAccountsConnection: (args?: {
    where?: PaymentAccountWhereInput;
    orderBy?: PaymentAccountOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => PaymentAccountConnectionPromise;
  picture: (where: PictureWhereUniqueInput) => PictureNullablePromise;
  pictures: (args?: {
    where?: PictureWhereInput;
    orderBy?: PictureOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Picture>;
  picturesConnection: (args?: {
    where?: PictureWhereInput;
    orderBy?: PictureOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => PictureConnectionPromise;
  review: (where: ReviewWhereUniqueInput) => ReviewNullablePromise;
  reviews: (args?: {
    where?: ReviewWhereInput;
    orderBy?: ReviewOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Review>;
  reviewsConnection: (args?: {
    where?: ReviewWhereInput;
    orderBy?: ReviewOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => ReviewConnectionPromise;
  user: (where: UserWhereUniqueInput) => UserNullablePromise;
  users: (args?: {
    where?: UserWhereInput;
    orderBy?: UserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<User>;
  usersConnection: (args?: {
    where?: UserWhereInput;
    orderBy?: UserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => UserConnectionPromise;
  vendor: (where: VendorWhereUniqueInput) => VendorNullablePromise;
  vendors: (args?: {
    where?: VendorWhereInput;
    orderBy?: VendorOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Vendor>;
  vendorsConnection: (args?: {
    where?: VendorWhereInput;
    orderBy?: VendorOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => VendorConnectionPromise;
  views: (where: ViewsWhereUniqueInput) => ViewsNullablePromise;
  viewses: (args?: {
    where?: ViewsWhereInput;
    orderBy?: ViewsOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Views>;
  viewsesConnection: (args?: {
    where?: ViewsWhereInput;
    orderBy?: ViewsOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => ViewsConnectionPromise;
  savedList: (where: savedListWhereUniqueInput) => savedListNullablePromise;
  savedLists: (args?: {
    where?: savedListWhereInput;
    orderBy?: savedListOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<savedList>;
  savedListsConnection: (args?: {
    where?: savedListWhereInput;
    orderBy?: savedListOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => savedListConnectionPromise;
  node: (args: { id: ID_Output }) => Node;

  /**
   * Mutations
   */

  createBooking: (data: BookingCreateInput) => BookingPromise;
  updateBooking: (args: {
    data: BookingUpdateInput;
    where: BookingWhereUniqueInput;
  }) => BookingPromise;
  updateManyBookings: (args: {
    data: BookingUpdateManyMutationInput;
    where?: BookingWhereInput;
  }) => BatchPayloadPromise;
  upsertBooking: (args: {
    where: BookingWhereUniqueInput;
    create: BookingCreateInput;
    update: BookingUpdateInput;
  }) => BookingPromise;
  deleteBooking: (where: BookingWhereUniqueInput) => BookingPromise;
  deleteManyBookings: (where?: BookingWhereInput) => BatchPayloadPromise;
  createListing: (data: ListingCreateInput) => ListingPromise;
  updateListing: (args: {
    data: ListingUpdateInput;
    where: ListingWhereUniqueInput;
  }) => ListingPromise;
  updateManyListings: (args: {
    data: ListingUpdateManyMutationInput;
    where?: ListingWhereInput;
  }) => BatchPayloadPromise;
  upsertListing: (args: {
    where: ListingWhereUniqueInput;
    create: ListingCreateInput;
    update: ListingUpdateInput;
  }) => ListingPromise;
  deleteListing: (where: ListingWhereUniqueInput) => ListingPromise;
  deleteManyListings: (where?: ListingWhereInput) => BatchPayloadPromise;
  createLocation: (data: LocationCreateInput) => LocationPromise;
  updateLocation: (args: {
    data: LocationUpdateInput;
    where: LocationWhereUniqueInput;
  }) => LocationPromise;
  updateManyLocations: (args: {
    data: LocationUpdateManyMutationInput;
    where?: LocationWhereInput;
  }) => BatchPayloadPromise;
  upsertLocation: (args: {
    where: LocationWhereUniqueInput;
    create: LocationCreateInput;
    update: LocationUpdateInput;
  }) => LocationPromise;
  deleteLocation: (where: LocationWhereUniqueInput) => LocationPromise;
  deleteManyLocations: (where?: LocationWhereInput) => BatchPayloadPromise;
  createPayment: (data: PaymentCreateInput) => PaymentPromise;
  updatePayment: (args: {
    data: PaymentUpdateInput;
    where: PaymentWhereUniqueInput;
  }) => PaymentPromise;
  updateManyPayments: (args: {
    data: PaymentUpdateManyMutationInput;
    where?: PaymentWhereInput;
  }) => BatchPayloadPromise;
  upsertPayment: (args: {
    where: PaymentWhereUniqueInput;
    create: PaymentCreateInput;
    update: PaymentUpdateInput;
  }) => PaymentPromise;
  deletePayment: (where: PaymentWhereUniqueInput) => PaymentPromise;
  deleteManyPayments: (where?: PaymentWhereInput) => BatchPayloadPromise;
  createPaymentAccount: (
    data: PaymentAccountCreateInput
  ) => PaymentAccountPromise;
  updatePaymentAccount: (args: {
    data: PaymentAccountUpdateInput;
    where: PaymentAccountWhereUniqueInput;
  }) => PaymentAccountPromise;
  updateManyPaymentAccounts: (args: {
    data: PaymentAccountUpdateManyMutationInput;
    where?: PaymentAccountWhereInput;
  }) => BatchPayloadPromise;
  upsertPaymentAccount: (args: {
    where: PaymentAccountWhereUniqueInput;
    create: PaymentAccountCreateInput;
    update: PaymentAccountUpdateInput;
  }) => PaymentAccountPromise;
  deletePaymentAccount: (
    where: PaymentAccountWhereUniqueInput
  ) => PaymentAccountPromise;
  deleteManyPaymentAccounts: (
    where?: PaymentAccountWhereInput
  ) => BatchPayloadPromise;
  createPicture: (data: PictureCreateInput) => PicturePromise;
  updatePicture: (args: {
    data: PictureUpdateInput;
    where: PictureWhereUniqueInput;
  }) => PicturePromise;
  updateManyPictures: (args: {
    data: PictureUpdateManyMutationInput;
    where?: PictureWhereInput;
  }) => BatchPayloadPromise;
  upsertPicture: (args: {
    where: PictureWhereUniqueInput;
    create: PictureCreateInput;
    update: PictureUpdateInput;
  }) => PicturePromise;
  deletePicture: (where: PictureWhereUniqueInput) => PicturePromise;
  deleteManyPictures: (where?: PictureWhereInput) => BatchPayloadPromise;
  createReview: (data: ReviewCreateInput) => ReviewPromise;
  updateReview: (args: {
    data: ReviewUpdateInput;
    where: ReviewWhereUniqueInput;
  }) => ReviewPromise;
  updateManyReviews: (args: {
    data: ReviewUpdateManyMutationInput;
    where?: ReviewWhereInput;
  }) => BatchPayloadPromise;
  upsertReview: (args: {
    where: ReviewWhereUniqueInput;
    create: ReviewCreateInput;
    update: ReviewUpdateInput;
  }) => ReviewPromise;
  deleteReview: (where: ReviewWhereUniqueInput) => ReviewPromise;
  deleteManyReviews: (where?: ReviewWhereInput) => BatchPayloadPromise;
  createUser: (data: UserCreateInput) => UserPromise;
  updateUser: (args: {
    data: UserUpdateInput;
    where: UserWhereUniqueInput;
  }) => UserPromise;
  updateManyUsers: (args: {
    data: UserUpdateManyMutationInput;
    where?: UserWhereInput;
  }) => BatchPayloadPromise;
  upsertUser: (args: {
    where: UserWhereUniqueInput;
    create: UserCreateInput;
    update: UserUpdateInput;
  }) => UserPromise;
  deleteUser: (where: UserWhereUniqueInput) => UserPromise;
  deleteManyUsers: (where?: UserWhereInput) => BatchPayloadPromise;
  createVendor: (data: VendorCreateInput) => VendorPromise;
  updateVendor: (args: {
    data: VendorUpdateInput;
    where: VendorWhereUniqueInput;
  }) => VendorPromise;
  updateManyVendors: (args: {
    data: VendorUpdateManyMutationInput;
    where?: VendorWhereInput;
  }) => BatchPayloadPromise;
  upsertVendor: (args: {
    where: VendorWhereUniqueInput;
    create: VendorCreateInput;
    update: VendorUpdateInput;
  }) => VendorPromise;
  deleteVendor: (where: VendorWhereUniqueInput) => VendorPromise;
  deleteManyVendors: (where?: VendorWhereInput) => BatchPayloadPromise;
  createViews: (data: ViewsCreateInput) => ViewsPromise;
  updateViews: (args: {
    data: ViewsUpdateInput;
    where: ViewsWhereUniqueInput;
  }) => ViewsPromise;
  updateManyViewses: (args: {
    data: ViewsUpdateManyMutationInput;
    where?: ViewsWhereInput;
  }) => BatchPayloadPromise;
  upsertViews: (args: {
    where: ViewsWhereUniqueInput;
    create: ViewsCreateInput;
    update: ViewsUpdateInput;
  }) => ViewsPromise;
  deleteViews: (where: ViewsWhereUniqueInput) => ViewsPromise;
  deleteManyViewses: (where?: ViewsWhereInput) => BatchPayloadPromise;
  createsavedList: (data: savedListCreateInput) => savedListPromise;
  updatesavedList: (args: {
    data: savedListUpdateInput;
    where: savedListWhereUniqueInput;
  }) => savedListPromise;
  upsertsavedList: (args: {
    where: savedListWhereUniqueInput;
    create: savedListCreateInput;
    update: savedListUpdateInput;
  }) => savedListPromise;
  deletesavedList: (where: savedListWhereUniqueInput) => savedListPromise;
  deleteManysavedLists: (where?: savedListWhereInput) => BatchPayloadPromise;

  /**
   * Subscriptions
   */

  $subscribe: Subscription;
}

export interface Subscription {
  booking: (
    where?: BookingSubscriptionWhereInput
  ) => BookingSubscriptionPayloadSubscription;
  listing: (
    where?: ListingSubscriptionWhereInput
  ) => ListingSubscriptionPayloadSubscription;
  location: (
    where?: LocationSubscriptionWhereInput
  ) => LocationSubscriptionPayloadSubscription;
  payment: (
    where?: PaymentSubscriptionWhereInput
  ) => PaymentSubscriptionPayloadSubscription;
  paymentAccount: (
    where?: PaymentAccountSubscriptionWhereInput
  ) => PaymentAccountSubscriptionPayloadSubscription;
  picture: (
    where?: PictureSubscriptionWhereInput
  ) => PictureSubscriptionPayloadSubscription;
  review: (
    where?: ReviewSubscriptionWhereInput
  ) => ReviewSubscriptionPayloadSubscription;
  user: (
    where?: UserSubscriptionWhereInput
  ) => UserSubscriptionPayloadSubscription;
  vendor: (
    where?: VendorSubscriptionWhereInput
  ) => VendorSubscriptionPayloadSubscription;
  views: (
    where?: ViewsSubscriptionWhereInput
  ) => ViewsSubscriptionPayloadSubscription;
  savedList: (
    where?: savedListSubscriptionWhereInput
  ) => savedListSubscriptionPayloadSubscription;
}

export interface ClientConstructor<T> {
  new (options?: BaseClientOptions): T;
}

/**
 * Types
 */

export type LocationOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "lat_ASC"
  | "lat_DESC"
  | "lng_ASC"
  | "lng_DESC"
  | "directions_ASC"
  | "directions_DESC";

export type PAYMENT_PROVIDER = "MPESA" | "CREDIT_CARD";

export type PaymentOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "serviceFee_ASC"
  | "serviceFee_DESC"
  | "price_ASC"
  | "price_DESC"
  | "totalPrice_ASC"
  | "totalPrice_DESC";

export type savedListOrderByInput = "id_ASC" | "id_DESC";

export type PictureOrderByInput = "id_ASC" | "id_DESC" | "src_ASC" | "src_DESC";

export type VendorOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "firstName_ASC"
  | "firstName_DESC"
  | "lastName_ASC"
  | "lastName_DESC"
  | "email_ASC"
  | "email_DESC"
  | "password_ASC"
  | "password_DESC"
  | "phone_ASC"
  | "phone_DESC"
  | "profilePhoto_ASC"
  | "profilePhoto_DESC"
  | "offer_ASC"
  | "offer_DESC"
  | "vendorType_ASC"
  | "vendorType_DESC";

export type ListingOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "title_ASC"
  | "title_DESC"
  | "description_ASC"
  | "description_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "maxGuests_ASC"
  | "maxGuests_DESC"
  | "pricePerPlate_ASC"
  | "pricePerPlate_DESC"
  | "coverPhoto_ASC"
  | "coverPhoto_DESC";

export type VENDOR_TYPE = "RESTAURANT" | "INDEPENDENT" | "BARS";

export type ReviewOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "title_ASC"
  | "title_DESC"
  | "comment_ASC"
  | "comment_DESC"
  | "stars_ASC"
  | "stars_DESC";

export type BookingOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "occasionDate_ASC"
  | "occasionDate_DESC"
  | "isFulfilled_ASC"
  | "isFulfilled_DESC";

export type UserOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "email_ASC"
  | "email_DESC"
  | "firstName_ASC"
  | "firstName_DESC"
  | "phone_ASC"
  | "phone_DESC"
  | "password_ASC"
  | "password_DESC"
  | "lastName_ASC"
  | "lastName_DESC"
  | "photoUrl_ASC"
  | "photoUrl_DESC";

export type ViewsOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "lastWeek_ASC"
  | "lastWeek_DESC";

export type MutationType = "CREATED" | "UPDATED" | "DELETED";

export type PaymentAccountOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "type_ASC"
  | "type_DESC";

export interface VendorUpsertWithoutListingsInput {
  update: VendorUpdateWithoutListingsDataInput;
  create: VendorCreateWithoutListingsInput;
}

export type BookingWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface LocationUpdateDataInput {
  lat?: Maybe<Float>;
  lng?: Maybe<Float>;
  user?: Maybe<UserUpdateOneWithoutAddressInput>;
  directions?: Maybe<String>;
}

export interface UserWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  email?: Maybe<String>;
  email_not?: Maybe<String>;
  email_in?: Maybe<String[] | String>;
  email_not_in?: Maybe<String[] | String>;
  email_lt?: Maybe<String>;
  email_lte?: Maybe<String>;
  email_gt?: Maybe<String>;
  email_gte?: Maybe<String>;
  email_contains?: Maybe<String>;
  email_not_contains?: Maybe<String>;
  email_starts_with?: Maybe<String>;
  email_not_starts_with?: Maybe<String>;
  email_ends_with?: Maybe<String>;
  email_not_ends_with?: Maybe<String>;
  firstName?: Maybe<String>;
  firstName_not?: Maybe<String>;
  firstName_in?: Maybe<String[] | String>;
  firstName_not_in?: Maybe<String[] | String>;
  firstName_lt?: Maybe<String>;
  firstName_lte?: Maybe<String>;
  firstName_gt?: Maybe<String>;
  firstName_gte?: Maybe<String>;
  firstName_contains?: Maybe<String>;
  firstName_not_contains?: Maybe<String>;
  firstName_starts_with?: Maybe<String>;
  firstName_not_starts_with?: Maybe<String>;
  firstName_ends_with?: Maybe<String>;
  firstName_not_ends_with?: Maybe<String>;
  phone?: Maybe<String>;
  phone_not?: Maybe<String>;
  phone_in?: Maybe<String[] | String>;
  phone_not_in?: Maybe<String[] | String>;
  phone_lt?: Maybe<String>;
  phone_lte?: Maybe<String>;
  phone_gt?: Maybe<String>;
  phone_gte?: Maybe<String>;
  phone_contains?: Maybe<String>;
  phone_not_contains?: Maybe<String>;
  phone_starts_with?: Maybe<String>;
  phone_not_starts_with?: Maybe<String>;
  phone_ends_with?: Maybe<String>;
  phone_not_ends_with?: Maybe<String>;
  password?: Maybe<String>;
  password_not?: Maybe<String>;
  password_in?: Maybe<String[] | String>;
  password_not_in?: Maybe<String[] | String>;
  password_lt?: Maybe<String>;
  password_lte?: Maybe<String>;
  password_gt?: Maybe<String>;
  password_gte?: Maybe<String>;
  password_contains?: Maybe<String>;
  password_not_contains?: Maybe<String>;
  password_starts_with?: Maybe<String>;
  password_not_starts_with?: Maybe<String>;
  password_ends_with?: Maybe<String>;
  password_not_ends_with?: Maybe<String>;
  lastName?: Maybe<String>;
  lastName_not?: Maybe<String>;
  lastName_in?: Maybe<String[] | String>;
  lastName_not_in?: Maybe<String[] | String>;
  lastName_lt?: Maybe<String>;
  lastName_lte?: Maybe<String>;
  lastName_gt?: Maybe<String>;
  lastName_gte?: Maybe<String>;
  lastName_contains?: Maybe<String>;
  lastName_not_contains?: Maybe<String>;
  lastName_starts_with?: Maybe<String>;
  lastName_not_starts_with?: Maybe<String>;
  lastName_ends_with?: Maybe<String>;
  lastName_not_ends_with?: Maybe<String>;
  address?: Maybe<LocationWhereInput>;
  saved?: Maybe<savedListWhereInput>;
  photoUrl?: Maybe<String>;
  photoUrl_not?: Maybe<String>;
  photoUrl_in?: Maybe<String[] | String>;
  photoUrl_not_in?: Maybe<String[] | String>;
  photoUrl_lt?: Maybe<String>;
  photoUrl_lte?: Maybe<String>;
  photoUrl_gt?: Maybe<String>;
  photoUrl_gte?: Maybe<String>;
  photoUrl_contains?: Maybe<String>;
  photoUrl_not_contains?: Maybe<String>;
  photoUrl_starts_with?: Maybe<String>;
  photoUrl_not_starts_with?: Maybe<String>;
  photoUrl_ends_with?: Maybe<String>;
  photoUrl_not_ends_with?: Maybe<String>;
  AND?: Maybe<UserWhereInput[] | UserWhereInput>;
  OR?: Maybe<UserWhereInput[] | UserWhereInput>;
  NOT?: Maybe<UserWhereInput[] | UserWhereInput>;
}

export interface UserUpdateOneWithoutAddressInput {
  create?: Maybe<UserCreateWithoutAddressInput>;
  update?: Maybe<UserUpdateWithoutAddressDataInput>;
  upsert?: Maybe<UserUpsertWithoutAddressInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export interface savedListWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  listings_every?: Maybe<ListingWhereInput>;
  listings_some?: Maybe<ListingWhereInput>;
  listings_none?: Maybe<ListingWhereInput>;
  AND?: Maybe<savedListWhereInput[] | savedListWhereInput>;
  OR?: Maybe<savedListWhereInput[] | savedListWhereInput>;
  NOT?: Maybe<savedListWhereInput[] | savedListWhereInput>;
}

export interface UserUpdateWithoutAddressDataInput {
  email?: Maybe<String>;
  firstName?: Maybe<String>;
  phone?: Maybe<String>;
  password?: Maybe<String>;
  lastName?: Maybe<String>;
  saved?: Maybe<savedListUpdateOneInput>;
  photoUrl?: Maybe<String>;
}

export interface PaymentAccountWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  type?: Maybe<PAYMENT_PROVIDER>;
  type_not?: Maybe<PAYMENT_PROVIDER>;
  type_in?: Maybe<PAYMENT_PROVIDER[] | PAYMENT_PROVIDER>;
  type_not_in?: Maybe<PAYMENT_PROVIDER[] | PAYMENT_PROVIDER>;
  user?: Maybe<UserWhereInput>;
  payments_every?: Maybe<PaymentWhereInput>;
  payments_some?: Maybe<PaymentWhereInput>;
  payments_none?: Maybe<PaymentWhereInput>;
  AND?: Maybe<PaymentAccountWhereInput[] | PaymentAccountWhereInput>;
  OR?: Maybe<PaymentAccountWhereInput[] | PaymentAccountWhereInput>;
  NOT?: Maybe<PaymentAccountWhereInput[] | PaymentAccountWhereInput>;
}

export interface PaymentAccountCreateOneWithoutPaymentsInput {
  create?: Maybe<PaymentAccountCreateWithoutPaymentsInput>;
  connect?: Maybe<PaymentAccountWhereUniqueInput>;
}

export interface PaymentUpsertWithWhereUniqueWithoutPaymentMethodInput {
  where: PaymentWhereUniqueInput;
  update: PaymentUpdateWithoutPaymentMethodDataInput;
  create: PaymentCreateWithoutPaymentMethodInput;
}

export interface PaymentAccountCreateWithoutPaymentsInput {
  id?: Maybe<ID_Input>;
  type?: Maybe<PAYMENT_PROVIDER>;
  user: UserCreateOneInput;
}

export interface UserUpsertWithoutAddressInput {
  update: UserUpdateWithoutAddressDataInput;
  create: UserCreateWithoutAddressInput;
}

export interface PictureCreateManyWithoutListingInput {
  create?: Maybe<
    PictureCreateWithoutListingInput[] | PictureCreateWithoutListingInput
  >;
  connect?: Maybe<PictureWhereUniqueInput[] | PictureWhereUniqueInput>;
}

export interface savedListSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<savedListWhereInput>;
  AND?: Maybe<
    savedListSubscriptionWhereInput[] | savedListSubscriptionWhereInput
  >;
  OR?: Maybe<
    savedListSubscriptionWhereInput[] | savedListSubscriptionWhereInput
  >;
  NOT?: Maybe<
    savedListSubscriptionWhereInput[] | savedListSubscriptionWhereInput
  >;
}

export interface PictureCreateWithoutListingInput {
  id?: Maybe<ID_Input>;
  src: String;
}

export interface ViewsSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<ViewsWhereInput>;
  AND?: Maybe<ViewsSubscriptionWhereInput[] | ViewsSubscriptionWhereInput>;
  OR?: Maybe<ViewsSubscriptionWhereInput[] | ViewsSubscriptionWhereInput>;
  NOT?: Maybe<ViewsSubscriptionWhereInput[] | ViewsSubscriptionWhereInput>;
}

export interface ListingCreateOneWithoutBookingsInput {
  create?: Maybe<ListingCreateWithoutBookingsInput>;
  connect?: Maybe<ListingWhereUniqueInput>;
}

export interface UserSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<UserWhereInput>;
  AND?: Maybe<UserSubscriptionWhereInput[] | UserSubscriptionWhereInput>;
  OR?: Maybe<UserSubscriptionWhereInput[] | UserSubscriptionWhereInput>;
  NOT?: Maybe<UserSubscriptionWhereInput[] | UserSubscriptionWhereInput>;
}

export interface ListingCreateWithoutBookingsInput {
  id?: Maybe<ID_Input>;
  title: String;
  description: String;
  maxGuests: Int;
  reviews?: Maybe<ReviewCreateManyWithoutListingInput>;
  vendor: VendorCreateOneWithoutListingsInput;
  pricePerPlate: Int;
  views?: Maybe<ViewsCreateOneWithoutListingInput>;
  coverPhoto: String;
  photos?: Maybe<PictureCreateManyWithoutListingInput>;
}

export interface ReviewSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<ReviewWhereInput>;
  AND?: Maybe<ReviewSubscriptionWhereInput[] | ReviewSubscriptionWhereInput>;
  OR?: Maybe<ReviewSubscriptionWhereInput[] | ReviewSubscriptionWhereInput>;
  NOT?: Maybe<ReviewSubscriptionWhereInput[] | ReviewSubscriptionWhereInput>;
}

export interface BookingUpdateInput {
  bookee?: Maybe<UserUpdateOneRequiredInput>;
  listing?: Maybe<ListingUpdateOneRequiredWithoutBookingsInput>;
  occasionDate?: Maybe<DateTimeInput>;
  location?: Maybe<LocationUpdateOneInput>;
  payment?: Maybe<PaymentUpdateOneWithoutBookingInput>;
  isFulfilled?: Maybe<Boolean>;
}

export interface PaymentAccountSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<PaymentAccountWhereInput>;
  AND?: Maybe<
    | PaymentAccountSubscriptionWhereInput[]
    | PaymentAccountSubscriptionWhereInput
  >;
  OR?: Maybe<
    | PaymentAccountSubscriptionWhereInput[]
    | PaymentAccountSubscriptionWhereInput
  >;
  NOT?: Maybe<
    | PaymentAccountSubscriptionWhereInput[]
    | PaymentAccountSubscriptionWhereInput
  >;
}

export interface UserUpdateOneRequiredInput {
  create?: Maybe<UserCreateInput>;
  update?: Maybe<UserUpdateDataInput>;
  upsert?: Maybe<UserUpsertNestedInput>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export interface ListingWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  title?: Maybe<String>;
  title_not?: Maybe<String>;
  title_in?: Maybe<String[] | String>;
  title_not_in?: Maybe<String[] | String>;
  title_lt?: Maybe<String>;
  title_lte?: Maybe<String>;
  title_gt?: Maybe<String>;
  title_gte?: Maybe<String>;
  title_contains?: Maybe<String>;
  title_not_contains?: Maybe<String>;
  title_starts_with?: Maybe<String>;
  title_not_starts_with?: Maybe<String>;
  title_ends_with?: Maybe<String>;
  title_not_ends_with?: Maybe<String>;
  description?: Maybe<String>;
  description_not?: Maybe<String>;
  description_in?: Maybe<String[] | String>;
  description_not_in?: Maybe<String[] | String>;
  description_lt?: Maybe<String>;
  description_lte?: Maybe<String>;
  description_gt?: Maybe<String>;
  description_gte?: Maybe<String>;
  description_contains?: Maybe<String>;
  description_not_contains?: Maybe<String>;
  description_starts_with?: Maybe<String>;
  description_not_starts_with?: Maybe<String>;
  description_ends_with?: Maybe<String>;
  description_not_ends_with?: Maybe<String>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  maxGuests?: Maybe<Int>;
  maxGuests_not?: Maybe<Int>;
  maxGuests_in?: Maybe<Int[] | Int>;
  maxGuests_not_in?: Maybe<Int[] | Int>;
  maxGuests_lt?: Maybe<Int>;
  maxGuests_lte?: Maybe<Int>;
  maxGuests_gt?: Maybe<Int>;
  maxGuests_gte?: Maybe<Int>;
  reviews_every?: Maybe<ReviewWhereInput>;
  reviews_some?: Maybe<ReviewWhereInput>;
  reviews_none?: Maybe<ReviewWhereInput>;
  vendor?: Maybe<VendorWhereInput>;
  pricePerPlate?: Maybe<Int>;
  pricePerPlate_not?: Maybe<Int>;
  pricePerPlate_in?: Maybe<Int[] | Int>;
  pricePerPlate_not_in?: Maybe<Int[] | Int>;
  pricePerPlate_lt?: Maybe<Int>;
  pricePerPlate_lte?: Maybe<Int>;
  pricePerPlate_gt?: Maybe<Int>;
  pricePerPlate_gte?: Maybe<Int>;
  views?: Maybe<ViewsWhereInput>;
  coverPhoto?: Maybe<String>;
  coverPhoto_not?: Maybe<String>;
  coverPhoto_in?: Maybe<String[] | String>;
  coverPhoto_not_in?: Maybe<String[] | String>;
  coverPhoto_lt?: Maybe<String>;
  coverPhoto_lte?: Maybe<String>;
  coverPhoto_gt?: Maybe<String>;
  coverPhoto_gte?: Maybe<String>;
  coverPhoto_contains?: Maybe<String>;
  coverPhoto_not_contains?: Maybe<String>;
  coverPhoto_starts_with?: Maybe<String>;
  coverPhoto_not_starts_with?: Maybe<String>;
  coverPhoto_ends_with?: Maybe<String>;
  coverPhoto_not_ends_with?: Maybe<String>;
  bookings_every?: Maybe<BookingWhereInput>;
  bookings_some?: Maybe<BookingWhereInput>;
  bookings_none?: Maybe<BookingWhereInput>;
  photos_every?: Maybe<PictureWhereInput>;
  photos_some?: Maybe<PictureWhereInput>;
  photos_none?: Maybe<PictureWhereInput>;
  AND?: Maybe<ListingWhereInput[] | ListingWhereInput>;
  OR?: Maybe<ListingWhereInput[] | ListingWhereInput>;
  NOT?: Maybe<ListingWhereInput[] | ListingWhereInput>;
}

export interface UserUpdateDataInput {
  email?: Maybe<String>;
  firstName?: Maybe<String>;
  phone?: Maybe<String>;
  password?: Maybe<String>;
  lastName?: Maybe<String>;
  address?: Maybe<LocationUpdateOneWithoutUserInput>;
  saved?: Maybe<savedListUpdateOneInput>;
  photoUrl?: Maybe<String>;
}

export interface ListingSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<ListingWhereInput>;
  AND?: Maybe<ListingSubscriptionWhereInput[] | ListingSubscriptionWhereInput>;
  OR?: Maybe<ListingSubscriptionWhereInput[] | ListingSubscriptionWhereInput>;
  NOT?: Maybe<ListingSubscriptionWhereInput[] | ListingSubscriptionWhereInput>;
}

export interface LocationUpdateOneWithoutUserInput {
  create?: Maybe<LocationCreateWithoutUserInput>;
  update?: Maybe<LocationUpdateWithoutUserDataInput>;
  upsert?: Maybe<LocationUpsertWithoutUserInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<LocationWhereUniqueInput>;
}

export interface savedListUpdateInput {
  listings?: Maybe<ListingUpdateManyInput>;
}

export interface LocationUpdateWithoutUserDataInput {
  lat?: Maybe<Float>;
  lng?: Maybe<Float>;
  directions?: Maybe<String>;
}

export interface ViewsUpdateManyMutationInput {
  lastWeek?: Maybe<Int>;
}

export interface LocationUpsertWithoutUserInput {
  update: LocationUpdateWithoutUserDataInput;
  create: LocationCreateWithoutUserInput;
}

export interface ListingUpdateWithoutViewsDataInput {
  title?: Maybe<String>;
  description?: Maybe<String>;
  maxGuests?: Maybe<Int>;
  reviews?: Maybe<ReviewUpdateManyWithoutListingInput>;
  vendor?: Maybe<VendorUpdateOneRequiredWithoutListingsInput>;
  pricePerPlate?: Maybe<Int>;
  coverPhoto?: Maybe<String>;
  bookings?: Maybe<BookingUpdateManyWithoutListingInput>;
  photos?: Maybe<PictureUpdateManyWithoutListingInput>;
}

export interface savedListUpdateOneInput {
  create?: Maybe<savedListCreateInput>;
  update?: Maybe<savedListUpdateDataInput>;
  upsert?: Maybe<savedListUpsertNestedInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<savedListWhereUniqueInput>;
}

export interface ListingUpdateOneRequiredWithoutViewsInput {
  create?: Maybe<ListingCreateWithoutViewsInput>;
  update?: Maybe<ListingUpdateWithoutViewsDataInput>;
  upsert?: Maybe<ListingUpsertWithoutViewsInput>;
  connect?: Maybe<ListingWhereUniqueInput>;
}

export interface savedListUpdateDataInput {
  listings?: Maybe<ListingUpdateManyInput>;
}

export interface ListingCreateWithoutViewsInput {
  id?: Maybe<ID_Input>;
  title: String;
  description: String;
  maxGuests: Int;
  reviews?: Maybe<ReviewCreateManyWithoutListingInput>;
  vendor: VendorCreateOneWithoutListingsInput;
  pricePerPlate: Int;
  coverPhoto: String;
  bookings?: Maybe<BookingCreateManyWithoutListingInput>;
  photos?: Maybe<PictureCreateManyWithoutListingInput>;
}

export interface ListingUpdateManyInput {
  create?: Maybe<ListingCreateInput[] | ListingCreateInput>;
  update?: Maybe<
    | ListingUpdateWithWhereUniqueNestedInput[]
    | ListingUpdateWithWhereUniqueNestedInput
  >;
  upsert?: Maybe<
    | ListingUpsertWithWhereUniqueNestedInput[]
    | ListingUpsertWithWhereUniqueNestedInput
  >;
  delete?: Maybe<ListingWhereUniqueInput[] | ListingWhereUniqueInput>;
  connect?: Maybe<ListingWhereUniqueInput[] | ListingWhereUniqueInput>;
  set?: Maybe<ListingWhereUniqueInput[] | ListingWhereUniqueInput>;
  disconnect?: Maybe<ListingWhereUniqueInput[] | ListingWhereUniqueInput>;
  deleteMany?: Maybe<ListingScalarWhereInput[] | ListingScalarWhereInput>;
  updateMany?: Maybe<
    | ListingUpdateManyWithWhereNestedInput[]
    | ListingUpdateManyWithWhereNestedInput
  >;
}

export type PaymentWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface ListingUpdateWithWhereUniqueNestedInput {
  where: ListingWhereUniqueInput;
  data: ListingUpdateDataInput;
}

export interface VendorUpdateManyMutationInput {
  firstName?: Maybe<String>;
  lastName?: Maybe<String>;
  email?: Maybe<String>;
  password?: Maybe<String>;
  phone?: Maybe<String>;
  profilePhoto?: Maybe<String>;
  offer?: Maybe<String>;
  vendorType?: Maybe<VENDOR_TYPE>;
}

export interface ListingUpdateDataInput {
  title?: Maybe<String>;
  description?: Maybe<String>;
  maxGuests?: Maybe<Int>;
  reviews?: Maybe<ReviewUpdateManyWithoutListingInput>;
  vendor?: Maybe<VendorUpdateOneRequiredWithoutListingsInput>;
  pricePerPlate?: Maybe<Int>;
  views?: Maybe<ViewsUpdateOneWithoutListingInput>;
  coverPhoto?: Maybe<String>;
  bookings?: Maybe<BookingUpdateManyWithoutListingInput>;
  photos?: Maybe<PictureUpdateManyWithoutListingInput>;
}

export type PaymentAccountWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface ReviewUpdateManyWithoutListingInput {
  create?: Maybe<
    ReviewCreateWithoutListingInput[] | ReviewCreateWithoutListingInput
  >;
  delete?: Maybe<ReviewWhereUniqueInput[] | ReviewWhereUniqueInput>;
  connect?: Maybe<ReviewWhereUniqueInput[] | ReviewWhereUniqueInput>;
  set?: Maybe<ReviewWhereUniqueInput[] | ReviewWhereUniqueInput>;
  disconnect?: Maybe<ReviewWhereUniqueInput[] | ReviewWhereUniqueInput>;
  update?: Maybe<
    | ReviewUpdateWithWhereUniqueWithoutListingInput[]
    | ReviewUpdateWithWhereUniqueWithoutListingInput
  >;
  upsert?: Maybe<
    | ReviewUpsertWithWhereUniqueWithoutListingInput[]
    | ReviewUpsertWithWhereUniqueWithoutListingInput
  >;
  deleteMany?: Maybe<ReviewScalarWhereInput[] | ReviewScalarWhereInput>;
  updateMany?: Maybe<
    | ReviewUpdateManyWithWhereNestedInput[]
    | ReviewUpdateManyWithWhereNestedInput
  >;
}

export interface ListingUpdateWithWhereUniqueWithoutVendorInput {
  where: ListingWhereUniqueInput;
  data: ListingUpdateWithoutVendorDataInput;
}

export interface ReviewUpdateWithWhereUniqueWithoutListingInput {
  where: ReviewWhereUniqueInput;
  data: ReviewUpdateWithoutListingDataInput;
}

export interface VendorUpdateInput {
  firstName?: Maybe<String>;
  lastName?: Maybe<String>;
  email?: Maybe<String>;
  password?: Maybe<String>;
  phone?: Maybe<String>;
  profilePhoto?: Maybe<String>;
  offer?: Maybe<String>;
  listings?: Maybe<ListingUpdateManyWithoutVendorInput>;
  vendorType?: Maybe<VENDOR_TYPE>;
}

export interface ReviewUpdateWithoutListingDataInput {
  title?: Maybe<String>;
  comment?: Maybe<String>;
  stars?: Maybe<Int>;
}

export interface ListingCreateWithoutVendorInput {
  id?: Maybe<ID_Input>;
  title: String;
  description: String;
  maxGuests: Int;
  reviews?: Maybe<ReviewCreateManyWithoutListingInput>;
  pricePerPlate: Int;
  views?: Maybe<ViewsCreateOneWithoutListingInput>;
  coverPhoto: String;
  bookings?: Maybe<BookingCreateManyWithoutListingInput>;
  photos?: Maybe<PictureCreateManyWithoutListingInput>;
}

export interface ReviewUpsertWithWhereUniqueWithoutListingInput {
  where: ReviewWhereUniqueInput;
  update: ReviewUpdateWithoutListingDataInput;
  create: ReviewCreateWithoutListingInput;
}

export interface VendorCreateInput {
  id?: Maybe<ID_Input>;
  firstName: String;
  lastName: String;
  email: String;
  password: String;
  phone: String;
  profilePhoto?: Maybe<String>;
  offer?: Maybe<String>;
  listings?: Maybe<ListingCreateManyWithoutVendorInput>;
  vendorType?: Maybe<VENDOR_TYPE>;
}

export interface ReviewScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  title?: Maybe<String>;
  title_not?: Maybe<String>;
  title_in?: Maybe<String[] | String>;
  title_not_in?: Maybe<String[] | String>;
  title_lt?: Maybe<String>;
  title_lte?: Maybe<String>;
  title_gt?: Maybe<String>;
  title_gte?: Maybe<String>;
  title_contains?: Maybe<String>;
  title_not_contains?: Maybe<String>;
  title_starts_with?: Maybe<String>;
  title_not_starts_with?: Maybe<String>;
  title_ends_with?: Maybe<String>;
  title_not_ends_with?: Maybe<String>;
  comment?: Maybe<String>;
  comment_not?: Maybe<String>;
  comment_in?: Maybe<String[] | String>;
  comment_not_in?: Maybe<String[] | String>;
  comment_lt?: Maybe<String>;
  comment_lte?: Maybe<String>;
  comment_gt?: Maybe<String>;
  comment_gte?: Maybe<String>;
  comment_contains?: Maybe<String>;
  comment_not_contains?: Maybe<String>;
  comment_starts_with?: Maybe<String>;
  comment_not_starts_with?: Maybe<String>;
  comment_ends_with?: Maybe<String>;
  comment_not_ends_with?: Maybe<String>;
  stars?: Maybe<Int>;
  stars_not?: Maybe<Int>;
  stars_in?: Maybe<Int[] | Int>;
  stars_not_in?: Maybe<Int[] | Int>;
  stars_lt?: Maybe<Int>;
  stars_lte?: Maybe<Int>;
  stars_gt?: Maybe<Int>;
  stars_gte?: Maybe<Int>;
  AND?: Maybe<ReviewScalarWhereInput[] | ReviewScalarWhereInput>;
  OR?: Maybe<ReviewScalarWhereInput[] | ReviewScalarWhereInput>;
  NOT?: Maybe<ReviewScalarWhereInput[] | ReviewScalarWhereInput>;
}

export interface UserUpdateManyMutationInput {
  email?: Maybe<String>;
  firstName?: Maybe<String>;
  phone?: Maybe<String>;
  password?: Maybe<String>;
  lastName?: Maybe<String>;
  photoUrl?: Maybe<String>;
}

export interface ReviewUpdateManyWithWhereNestedInput {
  where: ReviewScalarWhereInput;
  data: ReviewUpdateManyDataInput;
}

export interface ReviewUpdateManyMutationInput {
  title?: Maybe<String>;
  comment?: Maybe<String>;
  stars?: Maybe<Int>;
}

export interface ReviewUpdateManyDataInput {
  title?: Maybe<String>;
  comment?: Maybe<String>;
  stars?: Maybe<Int>;
}

export interface ListingUpsertWithoutReviewsInput {
  update: ListingUpdateWithoutReviewsDataInput;
  create: ListingCreateWithoutReviewsInput;
}

export interface VendorUpdateOneRequiredWithoutListingsInput {
  create?: Maybe<VendorCreateWithoutListingsInput>;
  update?: Maybe<VendorUpdateWithoutListingsDataInput>;
  upsert?: Maybe<VendorUpsertWithoutListingsInput>;
  connect?: Maybe<VendorWhereUniqueInput>;
}

export interface ListingUpdateOneRequiredWithoutReviewsInput {
  create?: Maybe<ListingCreateWithoutReviewsInput>;
  update?: Maybe<ListingUpdateWithoutReviewsDataInput>;
  upsert?: Maybe<ListingUpsertWithoutReviewsInput>;
  connect?: Maybe<ListingWhereUniqueInput>;
}

export interface VendorUpdateWithoutListingsDataInput {
  firstName?: Maybe<String>;
  lastName?: Maybe<String>;
  email?: Maybe<String>;
  password?: Maybe<String>;
  phone?: Maybe<String>;
  profilePhoto?: Maybe<String>;
  offer?: Maybe<String>;
  vendorType?: Maybe<VENDOR_TYPE>;
}

export type VendorWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
  email?: Maybe<String>;
}>;

export interface PaymentUpdateManyDataInput {
  serviceFee?: Maybe<Float>;
  price?: Maybe<Float>;
  totalPrice?: Maybe<Float>;
}

export interface ListingCreateOneWithoutReviewsInput {
  create?: Maybe<ListingCreateWithoutReviewsInput>;
  connect?: Maybe<ListingWhereUniqueInput>;
}

export interface ViewsUpdateOneWithoutListingInput {
  create?: Maybe<ViewsCreateWithoutListingInput>;
  update?: Maybe<ViewsUpdateWithoutListingDataInput>;
  upsert?: Maybe<ViewsUpsertWithoutListingInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<ViewsWhereUniqueInput>;
}

export interface PictureUpdateManyMutationInput {
  src?: Maybe<String>;
}

export interface ViewsUpdateWithoutListingDataInput {
  lastWeek?: Maybe<Int>;
}

export interface ListingUpsertWithoutPhotosInput {
  update: ListingUpdateWithoutPhotosDataInput;
  create: ListingCreateWithoutPhotosInput;
}

export interface ViewsUpsertWithoutListingInput {
  update: ViewsUpdateWithoutListingDataInput;
  create: ViewsCreateWithoutListingInput;
}

export interface ListingUpdateOneRequiredWithoutPhotosInput {
  create?: Maybe<ListingCreateWithoutPhotosInput>;
  update?: Maybe<ListingUpdateWithoutPhotosDataInput>;
  upsert?: Maybe<ListingUpsertWithoutPhotosInput>;
  connect?: Maybe<ListingWhereUniqueInput>;
}

export interface BookingUpdateManyWithoutListingInput {
  create?: Maybe<
    BookingCreateWithoutListingInput[] | BookingCreateWithoutListingInput
  >;
  delete?: Maybe<BookingWhereUniqueInput[] | BookingWhereUniqueInput>;
  connect?: Maybe<BookingWhereUniqueInput[] | BookingWhereUniqueInput>;
  set?: Maybe<BookingWhereUniqueInput[] | BookingWhereUniqueInput>;
  disconnect?: Maybe<BookingWhereUniqueInput[] | BookingWhereUniqueInput>;
  update?: Maybe<
    | BookingUpdateWithWhereUniqueWithoutListingInput[]
    | BookingUpdateWithWhereUniqueWithoutListingInput
  >;
  upsert?: Maybe<
    | BookingUpsertWithWhereUniqueWithoutListingInput[]
    | BookingUpsertWithWhereUniqueWithoutListingInput
  >;
  deleteMany?: Maybe<BookingScalarWhereInput[] | BookingScalarWhereInput>;
  updateMany?: Maybe<
    | BookingUpdateManyWithWhereNestedInput[]
    | BookingUpdateManyWithWhereNestedInput
  >;
}

export type savedListWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface BookingUpdateWithWhereUniqueWithoutListingInput {
  where: BookingWhereUniqueInput;
  data: BookingUpdateWithoutListingDataInput;
}

export interface ListingCreateOneWithoutPhotosInput {
  create?: Maybe<ListingCreateWithoutPhotosInput>;
  connect?: Maybe<ListingWhereUniqueInput>;
}

export interface BookingUpdateWithoutListingDataInput {
  bookee?: Maybe<UserUpdateOneRequiredInput>;
  occasionDate?: Maybe<DateTimeInput>;
  location?: Maybe<LocationUpdateOneInput>;
  payment?: Maybe<PaymentUpdateOneWithoutBookingInput>;
  isFulfilled?: Maybe<Boolean>;
}

export interface PaymentAccountUpdateManyMutationInput {
  type?: Maybe<PAYMENT_PROVIDER>;
}

export interface LocationUpdateOneInput {
  create?: Maybe<LocationCreateInput>;
  update?: Maybe<LocationUpdateDataInput>;
  upsert?: Maybe<LocationUpsertNestedInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<LocationWhereUniqueInput>;
}

export interface BookingCreateInput {
  id?: Maybe<ID_Input>;
  bookee: UserCreateOneInput;
  listing: ListingCreateOneWithoutBookingsInput;
  occasionDate: DateTimeInput;
  location?: Maybe<LocationCreateOneInput>;
  payment?: Maybe<PaymentCreateOneWithoutBookingInput>;
  isFulfilled?: Maybe<Boolean>;
}

export interface LocationWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  lat?: Maybe<Float>;
  lat_not?: Maybe<Float>;
  lat_in?: Maybe<Float[] | Float>;
  lat_not_in?: Maybe<Float[] | Float>;
  lat_lt?: Maybe<Float>;
  lat_lte?: Maybe<Float>;
  lat_gt?: Maybe<Float>;
  lat_gte?: Maybe<Float>;
  lng?: Maybe<Float>;
  lng_not?: Maybe<Float>;
  lng_in?: Maybe<Float[] | Float>;
  lng_not_in?: Maybe<Float[] | Float>;
  lng_lt?: Maybe<Float>;
  lng_lte?: Maybe<Float>;
  lng_gt?: Maybe<Float>;
  lng_gte?: Maybe<Float>;
  user?: Maybe<UserWhereInput>;
  directions?: Maybe<String>;
  directions_not?: Maybe<String>;
  directions_in?: Maybe<String[] | String>;
  directions_not_in?: Maybe<String[] | String>;
  directions_lt?: Maybe<String>;
  directions_lte?: Maybe<String>;
  directions_gt?: Maybe<String>;
  directions_gte?: Maybe<String>;
  directions_contains?: Maybe<String>;
  directions_not_contains?: Maybe<String>;
  directions_starts_with?: Maybe<String>;
  directions_not_starts_with?: Maybe<String>;
  directions_ends_with?: Maybe<String>;
  directions_not_ends_with?: Maybe<String>;
  AND?: Maybe<LocationWhereInput[] | LocationWhereInput>;
  OR?: Maybe<LocationWhereInput[] | LocationWhereInput>;
  NOT?: Maybe<LocationWhereInput[] | LocationWhereInput>;
}

export interface UserCreateInput {
  id?: Maybe<ID_Input>;
  email: String;
  firstName: String;
  phone?: Maybe<String>;
  password: String;
  lastName: String;
  address?: Maybe<LocationCreateOneWithoutUserInput>;
  saved?: Maybe<savedListCreateOneInput>;
  photoUrl?: Maybe<String>;
}

export interface PaymentWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  serviceFee?: Maybe<Float>;
  serviceFee_not?: Maybe<Float>;
  serviceFee_in?: Maybe<Float[] | Float>;
  serviceFee_not_in?: Maybe<Float[] | Float>;
  serviceFee_lt?: Maybe<Float>;
  serviceFee_lte?: Maybe<Float>;
  serviceFee_gt?: Maybe<Float>;
  serviceFee_gte?: Maybe<Float>;
  price?: Maybe<Float>;
  price_not?: Maybe<Float>;
  price_in?: Maybe<Float[] | Float>;
  price_not_in?: Maybe<Float[] | Float>;
  price_lt?: Maybe<Float>;
  price_lte?: Maybe<Float>;
  price_gt?: Maybe<Float>;
  price_gte?: Maybe<Float>;
  totalPrice?: Maybe<Float>;
  totalPrice_not?: Maybe<Float>;
  totalPrice_in?: Maybe<Float[] | Float>;
  totalPrice_not_in?: Maybe<Float[] | Float>;
  totalPrice_lt?: Maybe<Float>;
  totalPrice_lte?: Maybe<Float>;
  totalPrice_gt?: Maybe<Float>;
  totalPrice_gte?: Maybe<Float>;
  booking?: Maybe<BookingWhereInput>;
  paymentMethod?: Maybe<PaymentAccountWhereInput>;
  AND?: Maybe<PaymentWhereInput[] | PaymentWhereInput>;
  OR?: Maybe<PaymentWhereInput[] | PaymentWhereInput>;
  NOT?: Maybe<PaymentWhereInput[] | PaymentWhereInput>;
}

export interface LocationCreateWithoutUserInput {
  id?: Maybe<ID_Input>;
  lat: Float;
  lng: Float;
  directions: String;
}

export interface BookingWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  bookee?: Maybe<UserWhereInput>;
  listing?: Maybe<ListingWhereInput>;
  occasionDate?: Maybe<DateTimeInput>;
  occasionDate_not?: Maybe<DateTimeInput>;
  occasionDate_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  occasionDate_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  occasionDate_lt?: Maybe<DateTimeInput>;
  occasionDate_lte?: Maybe<DateTimeInput>;
  occasionDate_gt?: Maybe<DateTimeInput>;
  occasionDate_gte?: Maybe<DateTimeInput>;
  location?: Maybe<LocationWhereInput>;
  payment?: Maybe<PaymentWhereInput>;
  isFulfilled?: Maybe<Boolean>;
  isFulfilled_not?: Maybe<Boolean>;
  AND?: Maybe<BookingWhereInput[] | BookingWhereInput>;
  OR?: Maybe<BookingWhereInput[] | BookingWhereInput>;
  NOT?: Maybe<BookingWhereInput[] | BookingWhereInput>;
}

export interface savedListCreateInput {
  id?: Maybe<ID_Input>;
  listings?: Maybe<ListingCreateManyInput>;
}

export interface PictureWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  src?: Maybe<String>;
  src_not?: Maybe<String>;
  src_in?: Maybe<String[] | String>;
  src_not_in?: Maybe<String[] | String>;
  src_lt?: Maybe<String>;
  src_lte?: Maybe<String>;
  src_gt?: Maybe<String>;
  src_gte?: Maybe<String>;
  src_contains?: Maybe<String>;
  src_not_contains?: Maybe<String>;
  src_starts_with?: Maybe<String>;
  src_not_starts_with?: Maybe<String>;
  src_ends_with?: Maybe<String>;
  src_not_ends_with?: Maybe<String>;
  listing?: Maybe<ListingWhereInput>;
  AND?: Maybe<PictureWhereInput[] | PictureWhereInput>;
  OR?: Maybe<PictureWhereInput[] | PictureWhereInput>;
  NOT?: Maybe<PictureWhereInput[] | PictureWhereInput>;
}

export interface ListingCreateInput {
  id?: Maybe<ID_Input>;
  title: String;
  description: String;
  maxGuests: Int;
  reviews?: Maybe<ReviewCreateManyWithoutListingInput>;
  vendor: VendorCreateOneWithoutListingsInput;
  pricePerPlate: Int;
  views?: Maybe<ViewsCreateOneWithoutListingInput>;
  coverPhoto: String;
  bookings?: Maybe<BookingCreateManyWithoutListingInput>;
  photos?: Maybe<PictureCreateManyWithoutListingInput>;
}

export interface LocationUpsertNestedInput {
  update: LocationUpdateDataInput;
  create: LocationCreateInput;
}

export interface ReviewCreateWithoutListingInput {
  id?: Maybe<ID_Input>;
  title: String;
  comment: String;
  stars: Int;
}

export interface PaymentUpdateOneWithoutBookingInput {
  create?: Maybe<PaymentCreateWithoutBookingInput>;
  update?: Maybe<PaymentUpdateWithoutBookingDataInput>;
  upsert?: Maybe<PaymentUpsertWithoutBookingInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<PaymentWhereUniqueInput>;
}

export interface VendorCreateWithoutListingsInput {
  id?: Maybe<ID_Input>;
  firstName: String;
  lastName: String;
  email: String;
  password: String;
  phone: String;
  profilePhoto?: Maybe<String>;
  offer?: Maybe<String>;
  vendorType?: Maybe<VENDOR_TYPE>;
}

export interface PaymentUpdateWithoutBookingDataInput {
  serviceFee?: Maybe<Float>;
  price?: Maybe<Float>;
  totalPrice?: Maybe<Float>;
  paymentMethod?: Maybe<PaymentAccountUpdateOneRequiredWithoutPaymentsInput>;
}

export interface ViewsCreateWithoutListingInput {
  id?: Maybe<ID_Input>;
  lastWeek: Int;
}

export interface PaymentAccountUpdateOneRequiredWithoutPaymentsInput {
  create?: Maybe<PaymentAccountCreateWithoutPaymentsInput>;
  update?: Maybe<PaymentAccountUpdateWithoutPaymentsDataInput>;
  upsert?: Maybe<PaymentAccountUpsertWithoutPaymentsInput>;
  connect?: Maybe<PaymentAccountWhereUniqueInput>;
}

export interface BookingCreateWithoutListingInput {
  id?: Maybe<ID_Input>;
  bookee: UserCreateOneInput;
  occasionDate: DateTimeInput;
  location?: Maybe<LocationCreateOneInput>;
  payment?: Maybe<PaymentCreateOneWithoutBookingInput>;
  isFulfilled?: Maybe<Boolean>;
}

export interface PaymentAccountUpdateWithoutPaymentsDataInput {
  type?: Maybe<PAYMENT_PROVIDER>;
  user?: Maybe<UserUpdateOneRequiredInput>;
}

export interface LocationCreateInput {
  id?: Maybe<ID_Input>;
  lat: Float;
  lng: Float;
  user?: Maybe<UserCreateOneWithoutAddressInput>;
  directions: String;
}

export interface PaymentAccountUpsertWithoutPaymentsInput {
  update: PaymentAccountUpdateWithoutPaymentsDataInput;
  create: PaymentAccountCreateWithoutPaymentsInput;
}

export interface UserCreateWithoutAddressInput {
  id?: Maybe<ID_Input>;
  email: String;
  firstName: String;
  phone?: Maybe<String>;
  password: String;
  lastName: String;
  saved?: Maybe<savedListCreateOneInput>;
  photoUrl?: Maybe<String>;
}

export interface PaymentUpsertWithoutBookingInput {
  update: PaymentUpdateWithoutBookingDataInput;
  create: PaymentCreateWithoutBookingInput;
}

export interface PaymentCreateWithoutBookingInput {
  id?: Maybe<ID_Input>;
  serviceFee: Float;
  price: Float;
  totalPrice: Float;
  paymentMethod: PaymentAccountCreateOneWithoutPaymentsInput;
}

export interface BookingUpsertWithWhereUniqueWithoutListingInput {
  where: BookingWhereUniqueInput;
  update: BookingUpdateWithoutListingDataInput;
  create: BookingCreateWithoutListingInput;
}

export interface VendorWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  firstName?: Maybe<String>;
  firstName_not?: Maybe<String>;
  firstName_in?: Maybe<String[] | String>;
  firstName_not_in?: Maybe<String[] | String>;
  firstName_lt?: Maybe<String>;
  firstName_lte?: Maybe<String>;
  firstName_gt?: Maybe<String>;
  firstName_gte?: Maybe<String>;
  firstName_contains?: Maybe<String>;
  firstName_not_contains?: Maybe<String>;
  firstName_starts_with?: Maybe<String>;
  firstName_not_starts_with?: Maybe<String>;
  firstName_ends_with?: Maybe<String>;
  firstName_not_ends_with?: Maybe<String>;
  lastName?: Maybe<String>;
  lastName_not?: Maybe<String>;
  lastName_in?: Maybe<String[] | String>;
  lastName_not_in?: Maybe<String[] | String>;
  lastName_lt?: Maybe<String>;
  lastName_lte?: Maybe<String>;
  lastName_gt?: Maybe<String>;
  lastName_gte?: Maybe<String>;
  lastName_contains?: Maybe<String>;
  lastName_not_contains?: Maybe<String>;
  lastName_starts_with?: Maybe<String>;
  lastName_not_starts_with?: Maybe<String>;
  lastName_ends_with?: Maybe<String>;
  lastName_not_ends_with?: Maybe<String>;
  email?: Maybe<String>;
  email_not?: Maybe<String>;
  email_in?: Maybe<String[] | String>;
  email_not_in?: Maybe<String[] | String>;
  email_lt?: Maybe<String>;
  email_lte?: Maybe<String>;
  email_gt?: Maybe<String>;
  email_gte?: Maybe<String>;
  email_contains?: Maybe<String>;
  email_not_contains?: Maybe<String>;
  email_starts_with?: Maybe<String>;
  email_not_starts_with?: Maybe<String>;
  email_ends_with?: Maybe<String>;
  email_not_ends_with?: Maybe<String>;
  password?: Maybe<String>;
  password_not?: Maybe<String>;
  password_in?: Maybe<String[] | String>;
  password_not_in?: Maybe<String[] | String>;
  password_lt?: Maybe<String>;
  password_lte?: Maybe<String>;
  password_gt?: Maybe<String>;
  password_gte?: Maybe<String>;
  password_contains?: Maybe<String>;
  password_not_contains?: Maybe<String>;
  password_starts_with?: Maybe<String>;
  password_not_starts_with?: Maybe<String>;
  password_ends_with?: Maybe<String>;
  password_not_ends_with?: Maybe<String>;
  phone?: Maybe<String>;
  phone_not?: Maybe<String>;
  phone_in?: Maybe<String[] | String>;
  phone_not_in?: Maybe<String[] | String>;
  phone_lt?: Maybe<String>;
  phone_lte?: Maybe<String>;
  phone_gt?: Maybe<String>;
  phone_gte?: Maybe<String>;
  phone_contains?: Maybe<String>;
  phone_not_contains?: Maybe<String>;
  phone_starts_with?: Maybe<String>;
  phone_not_starts_with?: Maybe<String>;
  phone_ends_with?: Maybe<String>;
  phone_not_ends_with?: Maybe<String>;
  profilePhoto?: Maybe<String>;
  profilePhoto_not?: Maybe<String>;
  profilePhoto_in?: Maybe<String[] | String>;
  profilePhoto_not_in?: Maybe<String[] | String>;
  profilePhoto_lt?: Maybe<String>;
  profilePhoto_lte?: Maybe<String>;
  profilePhoto_gt?: Maybe<String>;
  profilePhoto_gte?: Maybe<String>;
  profilePhoto_contains?: Maybe<String>;
  profilePhoto_not_contains?: Maybe<String>;
  profilePhoto_starts_with?: Maybe<String>;
  profilePhoto_not_starts_with?: Maybe<String>;
  profilePhoto_ends_with?: Maybe<String>;
  profilePhoto_not_ends_with?: Maybe<String>;
  offer?: Maybe<String>;
  offer_not?: Maybe<String>;
  offer_in?: Maybe<String[] | String>;
  offer_not_in?: Maybe<String[] | String>;
  offer_lt?: Maybe<String>;
  offer_lte?: Maybe<String>;
  offer_gt?: Maybe<String>;
  offer_gte?: Maybe<String>;
  offer_contains?: Maybe<String>;
  offer_not_contains?: Maybe<String>;
  offer_starts_with?: Maybe<String>;
  offer_not_starts_with?: Maybe<String>;
  offer_ends_with?: Maybe<String>;
  offer_not_ends_with?: Maybe<String>;
  listings_every?: Maybe<ListingWhereInput>;
  listings_some?: Maybe<ListingWhereInput>;
  listings_none?: Maybe<ListingWhereInput>;
  vendorType?: Maybe<VENDOR_TYPE>;
  vendorType_not?: Maybe<VENDOR_TYPE>;
  vendorType_in?: Maybe<VENDOR_TYPE[] | VENDOR_TYPE>;
  vendorType_not_in?: Maybe<VENDOR_TYPE[] | VENDOR_TYPE>;
  AND?: Maybe<VendorWhereInput[] | VendorWhereInput>;
  OR?: Maybe<VendorWhereInput[] | VendorWhereInput>;
  NOT?: Maybe<VendorWhereInput[] | VendorWhereInput>;
}

export interface BookingScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  occasionDate?: Maybe<DateTimeInput>;
  occasionDate_not?: Maybe<DateTimeInput>;
  occasionDate_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  occasionDate_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  occasionDate_lt?: Maybe<DateTimeInput>;
  occasionDate_lte?: Maybe<DateTimeInput>;
  occasionDate_gt?: Maybe<DateTimeInput>;
  occasionDate_gte?: Maybe<DateTimeInput>;
  isFulfilled?: Maybe<Boolean>;
  isFulfilled_not?: Maybe<Boolean>;
  AND?: Maybe<BookingScalarWhereInput[] | BookingScalarWhereInput>;
  OR?: Maybe<BookingScalarWhereInput[] | BookingScalarWhereInput>;
  NOT?: Maybe<BookingScalarWhereInput[] | BookingScalarWhereInput>;
}

export interface ReviewWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  title?: Maybe<String>;
  title_not?: Maybe<String>;
  title_in?: Maybe<String[] | String>;
  title_not_in?: Maybe<String[] | String>;
  title_lt?: Maybe<String>;
  title_lte?: Maybe<String>;
  title_gt?: Maybe<String>;
  title_gte?: Maybe<String>;
  title_contains?: Maybe<String>;
  title_not_contains?: Maybe<String>;
  title_starts_with?: Maybe<String>;
  title_not_starts_with?: Maybe<String>;
  title_ends_with?: Maybe<String>;
  title_not_ends_with?: Maybe<String>;
  comment?: Maybe<String>;
  comment_not?: Maybe<String>;
  comment_in?: Maybe<String[] | String>;
  comment_not_in?: Maybe<String[] | String>;
  comment_lt?: Maybe<String>;
  comment_lte?: Maybe<String>;
  comment_gt?: Maybe<String>;
  comment_gte?: Maybe<String>;
  comment_contains?: Maybe<String>;
  comment_not_contains?: Maybe<String>;
  comment_starts_with?: Maybe<String>;
  comment_not_starts_with?: Maybe<String>;
  comment_ends_with?: Maybe<String>;
  comment_not_ends_with?: Maybe<String>;
  stars?: Maybe<Int>;
  stars_not?: Maybe<Int>;
  stars_in?: Maybe<Int[] | Int>;
  stars_not_in?: Maybe<Int[] | Int>;
  stars_lt?: Maybe<Int>;
  stars_lte?: Maybe<Int>;
  stars_gt?: Maybe<Int>;
  stars_gte?: Maybe<Int>;
  listing?: Maybe<ListingWhereInput>;
  AND?: Maybe<ReviewWhereInput[] | ReviewWhereInput>;
  OR?: Maybe<ReviewWhereInput[] | ReviewWhereInput>;
  NOT?: Maybe<ReviewWhereInput[] | ReviewWhereInput>;
}

export interface BookingUpdateManyWithWhereNestedInput {
  where: BookingScalarWhereInput;
  data: BookingUpdateManyDataInput;
}

export interface PaymentSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<PaymentWhereInput>;
  AND?: Maybe<PaymentSubscriptionWhereInput[] | PaymentSubscriptionWhereInput>;
  OR?: Maybe<PaymentSubscriptionWhereInput[] | PaymentSubscriptionWhereInput>;
  NOT?: Maybe<PaymentSubscriptionWhereInput[] | PaymentSubscriptionWhereInput>;
}

export interface BookingUpdateManyDataInput {
  occasionDate?: Maybe<DateTimeInput>;
  isFulfilled?: Maybe<Boolean>;
}

export interface BookingSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<BookingWhereInput>;
  AND?: Maybe<BookingSubscriptionWhereInput[] | BookingSubscriptionWhereInput>;
  OR?: Maybe<BookingSubscriptionWhereInput[] | BookingSubscriptionWhereInput>;
  NOT?: Maybe<BookingSubscriptionWhereInput[] | BookingSubscriptionWhereInput>;
}

export interface PictureUpdateManyWithoutListingInput {
  create?: Maybe<
    PictureCreateWithoutListingInput[] | PictureCreateWithoutListingInput
  >;
  delete?: Maybe<PictureWhereUniqueInput[] | PictureWhereUniqueInput>;
  connect?: Maybe<PictureWhereUniqueInput[] | PictureWhereUniqueInput>;
  set?: Maybe<PictureWhereUniqueInput[] | PictureWhereUniqueInput>;
  disconnect?: Maybe<PictureWhereUniqueInput[] | PictureWhereUniqueInput>;
  update?: Maybe<
    | PictureUpdateWithWhereUniqueWithoutListingInput[]
    | PictureUpdateWithWhereUniqueWithoutListingInput
  >;
  upsert?: Maybe<
    | PictureUpsertWithWhereUniqueWithoutListingInput[]
    | PictureUpsertWithWhereUniqueWithoutListingInput
  >;
  deleteMany?: Maybe<PictureScalarWhereInput[] | PictureScalarWhereInput>;
  updateMany?: Maybe<
    | PictureUpdateManyWithWhereNestedInput[]
    | PictureUpdateManyWithWhereNestedInput
  >;
}

export interface ListingUpsertWithoutViewsInput {
  update: ListingUpdateWithoutViewsDataInput;
  create: ListingCreateWithoutViewsInput;
}

export interface PictureUpdateWithWhereUniqueWithoutListingInput {
  where: PictureWhereUniqueInput;
  data: PictureUpdateWithoutListingDataInput;
}

export interface ViewsUpdateInput {
  lastWeek?: Maybe<Int>;
  listing?: Maybe<ListingUpdateOneRequiredWithoutViewsInput>;
}

export interface PictureUpdateWithoutListingDataInput {
  src?: Maybe<String>;
}

export interface ViewsCreateInput {
  id?: Maybe<ID_Input>;
  lastWeek: Int;
  listing: ListingCreateOneWithoutViewsInput;
}

export interface PictureUpsertWithWhereUniqueWithoutListingInput {
  where: PictureWhereUniqueInput;
  update: PictureUpdateWithoutListingDataInput;
  create: PictureCreateWithoutListingInput;
}

export interface ListingUpdateWithoutVendorDataInput {
  title?: Maybe<String>;
  description?: Maybe<String>;
  maxGuests?: Maybe<Int>;
  reviews?: Maybe<ReviewUpdateManyWithoutListingInput>;
  pricePerPlate?: Maybe<Int>;
  views?: Maybe<ViewsUpdateOneWithoutListingInput>;
  coverPhoto?: Maybe<String>;
  bookings?: Maybe<BookingUpdateManyWithoutListingInput>;
  photos?: Maybe<PictureUpdateManyWithoutListingInput>;
}

export interface PictureScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  src?: Maybe<String>;
  src_not?: Maybe<String>;
  src_in?: Maybe<String[] | String>;
  src_not_in?: Maybe<String[] | String>;
  src_lt?: Maybe<String>;
  src_lte?: Maybe<String>;
  src_gt?: Maybe<String>;
  src_gte?: Maybe<String>;
  src_contains?: Maybe<String>;
  src_not_contains?: Maybe<String>;
  src_starts_with?: Maybe<String>;
  src_not_starts_with?: Maybe<String>;
  src_ends_with?: Maybe<String>;
  src_not_ends_with?: Maybe<String>;
  AND?: Maybe<PictureScalarWhereInput[] | PictureScalarWhereInput>;
  OR?: Maybe<PictureScalarWhereInput[] | PictureScalarWhereInput>;
  NOT?: Maybe<PictureScalarWhereInput[] | PictureScalarWhereInput>;
}

export type PictureWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface PictureUpdateManyWithWhereNestedInput {
  where: PictureScalarWhereInput;
  data: PictureUpdateManyDataInput;
}

export type ReviewWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface PictureUpdateManyDataInput {
  src?: Maybe<String>;
}

export type UserWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
  email?: Maybe<String>;
}>;

export interface ListingUpsertWithWhereUniqueNestedInput {
  where: ListingWhereUniqueInput;
  update: ListingUpdateDataInput;
  create: ListingCreateInput;
}

export interface ReviewUpdateInput {
  title?: Maybe<String>;
  comment?: Maybe<String>;
  stars?: Maybe<Int>;
  listing?: Maybe<ListingUpdateOneRequiredWithoutReviewsInput>;
}

export interface ListingScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  title?: Maybe<String>;
  title_not?: Maybe<String>;
  title_in?: Maybe<String[] | String>;
  title_not_in?: Maybe<String[] | String>;
  title_lt?: Maybe<String>;
  title_lte?: Maybe<String>;
  title_gt?: Maybe<String>;
  title_gte?: Maybe<String>;
  title_contains?: Maybe<String>;
  title_not_contains?: Maybe<String>;
  title_starts_with?: Maybe<String>;
  title_not_starts_with?: Maybe<String>;
  title_ends_with?: Maybe<String>;
  title_not_ends_with?: Maybe<String>;
  description?: Maybe<String>;
  description_not?: Maybe<String>;
  description_in?: Maybe<String[] | String>;
  description_not_in?: Maybe<String[] | String>;
  description_lt?: Maybe<String>;
  description_lte?: Maybe<String>;
  description_gt?: Maybe<String>;
  description_gte?: Maybe<String>;
  description_contains?: Maybe<String>;
  description_not_contains?: Maybe<String>;
  description_starts_with?: Maybe<String>;
  description_not_starts_with?: Maybe<String>;
  description_ends_with?: Maybe<String>;
  description_not_ends_with?: Maybe<String>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  maxGuests?: Maybe<Int>;
  maxGuests_not?: Maybe<Int>;
  maxGuests_in?: Maybe<Int[] | Int>;
  maxGuests_not_in?: Maybe<Int[] | Int>;
  maxGuests_lt?: Maybe<Int>;
  maxGuests_lte?: Maybe<Int>;
  maxGuests_gt?: Maybe<Int>;
  maxGuests_gte?: Maybe<Int>;
  pricePerPlate?: Maybe<Int>;
  pricePerPlate_not?: Maybe<Int>;
  pricePerPlate_in?: Maybe<Int[] | Int>;
  pricePerPlate_not_in?: Maybe<Int[] | Int>;
  pricePerPlate_lt?: Maybe<Int>;
  pricePerPlate_lte?: Maybe<Int>;
  pricePerPlate_gt?: Maybe<Int>;
  pricePerPlate_gte?: Maybe<Int>;
  coverPhoto?: Maybe<String>;
  coverPhoto_not?: Maybe<String>;
  coverPhoto_in?: Maybe<String[] | String>;
  coverPhoto_not_in?: Maybe<String[] | String>;
  coverPhoto_lt?: Maybe<String>;
  coverPhoto_lte?: Maybe<String>;
  coverPhoto_gt?: Maybe<String>;
  coverPhoto_gte?: Maybe<String>;
  coverPhoto_contains?: Maybe<String>;
  coverPhoto_not_contains?: Maybe<String>;
  coverPhoto_starts_with?: Maybe<String>;
  coverPhoto_not_starts_with?: Maybe<String>;
  coverPhoto_ends_with?: Maybe<String>;
  coverPhoto_not_ends_with?: Maybe<String>;
  AND?: Maybe<ListingScalarWhereInput[] | ListingScalarWhereInput>;
  OR?: Maybe<ListingScalarWhereInput[] | ListingScalarWhereInput>;
  NOT?: Maybe<ListingScalarWhereInput[] | ListingScalarWhereInput>;
}

export interface ReviewCreateInput {
  id?: Maybe<ID_Input>;
  title: String;
  comment: String;
  stars: Int;
  listing: ListingCreateOneWithoutReviewsInput;
}

export interface ListingUpdateManyWithWhereNestedInput {
  where: ListingScalarWhereInput;
  data: ListingUpdateManyDataInput;
}

export interface ListingUpdateWithoutPhotosDataInput {
  title?: Maybe<String>;
  description?: Maybe<String>;
  maxGuests?: Maybe<Int>;
  reviews?: Maybe<ReviewUpdateManyWithoutListingInput>;
  vendor?: Maybe<VendorUpdateOneRequiredWithoutListingsInput>;
  pricePerPlate?: Maybe<Int>;
  views?: Maybe<ViewsUpdateOneWithoutListingInput>;
  coverPhoto?: Maybe<String>;
  bookings?: Maybe<BookingUpdateManyWithoutListingInput>;
}

export interface ListingUpdateManyDataInput {
  title?: Maybe<String>;
  description?: Maybe<String>;
  maxGuests?: Maybe<Int>;
  pricePerPlate?: Maybe<Int>;
  coverPhoto?: Maybe<String>;
}

export interface ListingCreateWithoutPhotosInput {
  id?: Maybe<ID_Input>;
  title: String;
  description: String;
  maxGuests: Int;
  reviews?: Maybe<ReviewCreateManyWithoutListingInput>;
  vendor: VendorCreateOneWithoutListingsInput;
  pricePerPlate: Int;
  views?: Maybe<ViewsCreateOneWithoutListingInput>;
  coverPhoto: String;
  bookings?: Maybe<BookingCreateManyWithoutListingInput>;
}

export interface savedListUpsertNestedInput {
  update: savedListUpdateDataInput;
  create: savedListCreateInput;
}

export interface LocationCreateOneWithoutUserInput {
  create?: Maybe<LocationCreateWithoutUserInput>;
  connect?: Maybe<LocationWhereUniqueInput>;
}

export interface UserUpsertNestedInput {
  update: UserUpdateDataInput;
  create: UserCreateInput;
}

export interface ListingCreateManyInput {
  create?: Maybe<ListingCreateInput[] | ListingCreateInput>;
  connect?: Maybe<ListingWhereUniqueInput[] | ListingWhereUniqueInput>;
}

export interface ListingUpdateOneRequiredWithoutBookingsInput {
  create?: Maybe<ListingCreateWithoutBookingsInput>;
  update?: Maybe<ListingUpdateWithoutBookingsDataInput>;
  upsert?: Maybe<ListingUpsertWithoutBookingsInput>;
  connect?: Maybe<ListingWhereUniqueInput>;
}

export interface VendorCreateOneWithoutListingsInput {
  create?: Maybe<VendorCreateWithoutListingsInput>;
  connect?: Maybe<VendorWhereUniqueInput>;
}

export interface ListingUpdateWithoutBookingsDataInput {
  title?: Maybe<String>;
  description?: Maybe<String>;
  maxGuests?: Maybe<Int>;
  reviews?: Maybe<ReviewUpdateManyWithoutListingInput>;
  vendor?: Maybe<VendorUpdateOneRequiredWithoutListingsInput>;
  pricePerPlate?: Maybe<Int>;
  views?: Maybe<ViewsUpdateOneWithoutListingInput>;
  coverPhoto?: Maybe<String>;
  photos?: Maybe<PictureUpdateManyWithoutListingInput>;
}

export interface BookingCreateManyWithoutListingInput {
  create?: Maybe<
    BookingCreateWithoutListingInput[] | BookingCreateWithoutListingInput
  >;
  connect?: Maybe<BookingWhereUniqueInput[] | BookingWhereUniqueInput>;
}

export interface ListingUpsertWithoutBookingsInput {
  update: ListingUpdateWithoutBookingsDataInput;
  create: ListingCreateWithoutBookingsInput;
}

export interface UserCreateOneWithoutAddressInput {
  create?: Maybe<UserCreateWithoutAddressInput>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export interface BookingUpdateManyMutationInput {
  occasionDate?: Maybe<DateTimeInput>;
  isFulfilled?: Maybe<Boolean>;
}

export interface ViewsWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  lastWeek?: Maybe<Int>;
  lastWeek_not?: Maybe<Int>;
  lastWeek_in?: Maybe<Int[] | Int>;
  lastWeek_not_in?: Maybe<Int[] | Int>;
  lastWeek_lt?: Maybe<Int>;
  lastWeek_lte?: Maybe<Int>;
  lastWeek_gt?: Maybe<Int>;
  lastWeek_gte?: Maybe<Int>;
  listing?: Maybe<ListingWhereInput>;
  AND?: Maybe<ViewsWhereInput[] | ViewsWhereInput>;
  OR?: Maybe<ViewsWhereInput[] | ViewsWhereInput>;
  NOT?: Maybe<ViewsWhereInput[] | ViewsWhereInput>;
}

export interface PaymentUpdateManyWithWhereNestedInput {
  where: PaymentScalarWhereInput;
  data: PaymentUpdateManyDataInput;
}

export interface PictureSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<PictureWhereInput>;
  AND?: Maybe<PictureSubscriptionWhereInput[] | PictureSubscriptionWhereInput>;
  OR?: Maybe<PictureSubscriptionWhereInput[] | PictureSubscriptionWhereInput>;
  NOT?: Maybe<PictureSubscriptionWhereInput[] | PictureSubscriptionWhereInput>;
}

export interface PaymentScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  serviceFee?: Maybe<Float>;
  serviceFee_not?: Maybe<Float>;
  serviceFee_in?: Maybe<Float[] | Float>;
  serviceFee_not_in?: Maybe<Float[] | Float>;
  serviceFee_lt?: Maybe<Float>;
  serviceFee_lte?: Maybe<Float>;
  serviceFee_gt?: Maybe<Float>;
  serviceFee_gte?: Maybe<Float>;
  price?: Maybe<Float>;
  price_not?: Maybe<Float>;
  price_in?: Maybe<Float[] | Float>;
  price_not_in?: Maybe<Float[] | Float>;
  price_lt?: Maybe<Float>;
  price_lte?: Maybe<Float>;
  price_gt?: Maybe<Float>;
  price_gte?: Maybe<Float>;
  totalPrice?: Maybe<Float>;
  totalPrice_not?: Maybe<Float>;
  totalPrice_in?: Maybe<Float[] | Float>;
  totalPrice_not_in?: Maybe<Float[] | Float>;
  totalPrice_lt?: Maybe<Float>;
  totalPrice_lte?: Maybe<Float>;
  totalPrice_gt?: Maybe<Float>;
  totalPrice_gte?: Maybe<Float>;
  AND?: Maybe<PaymentScalarWhereInput[] | PaymentScalarWhereInput>;
  OR?: Maybe<PaymentScalarWhereInput[] | PaymentScalarWhereInput>;
  NOT?: Maybe<PaymentScalarWhereInput[] | PaymentScalarWhereInput>;
}

export type ListingWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface ListingUpdateInput {
  title?: Maybe<String>;
  description?: Maybe<String>;
  maxGuests?: Maybe<Int>;
  reviews?: Maybe<ReviewUpdateManyWithoutListingInput>;
  vendor?: Maybe<VendorUpdateOneRequiredWithoutListingsInput>;
  pricePerPlate?: Maybe<Int>;
  views?: Maybe<ViewsUpdateOneWithoutListingInput>;
  coverPhoto?: Maybe<String>;
  bookings?: Maybe<BookingUpdateManyWithoutListingInput>;
  photos?: Maybe<PictureUpdateManyWithoutListingInput>;
}

export interface ListingCreateOneWithoutViewsInput {
  create?: Maybe<ListingCreateWithoutViewsInput>;
  connect?: Maybe<ListingWhereUniqueInput>;
}

export interface ListingUpdateManyMutationInput {
  title?: Maybe<String>;
  description?: Maybe<String>;
  maxGuests?: Maybe<Int>;
  pricePerPlate?: Maybe<Int>;
  coverPhoto?: Maybe<String>;
}

export interface ListingUpdateManyWithoutVendorInput {
  create?: Maybe<
    ListingCreateWithoutVendorInput[] | ListingCreateWithoutVendorInput
  >;
  delete?: Maybe<ListingWhereUniqueInput[] | ListingWhereUniqueInput>;
  connect?: Maybe<ListingWhereUniqueInput[] | ListingWhereUniqueInput>;
  set?: Maybe<ListingWhereUniqueInput[] | ListingWhereUniqueInput>;
  disconnect?: Maybe<ListingWhereUniqueInput[] | ListingWhereUniqueInput>;
  update?: Maybe<
    | ListingUpdateWithWhereUniqueWithoutVendorInput[]
    | ListingUpdateWithWhereUniqueWithoutVendorInput
  >;
  upsert?: Maybe<
    | ListingUpsertWithWhereUniqueWithoutVendorInput[]
    | ListingUpsertWithWhereUniqueWithoutVendorInput
  >;
  deleteMany?: Maybe<ListingScalarWhereInput[] | ListingScalarWhereInput>;
  updateMany?: Maybe<
    | ListingUpdateManyWithWhereNestedInput[]
    | ListingUpdateManyWithWhereNestedInput
  >;
}

export interface LocationUpdateInput {
  lat?: Maybe<Float>;
  lng?: Maybe<Float>;
  user?: Maybe<UserUpdateOneWithoutAddressInput>;
  directions?: Maybe<String>;
}

export interface UserUpdateInput {
  email?: Maybe<String>;
  firstName?: Maybe<String>;
  phone?: Maybe<String>;
  password?: Maybe<String>;
  lastName?: Maybe<String>;
  address?: Maybe<LocationUpdateOneWithoutUserInput>;
  saved?: Maybe<savedListUpdateOneInput>;
  photoUrl?: Maybe<String>;
}

export interface LocationUpdateManyMutationInput {
  lat?: Maybe<Float>;
  lng?: Maybe<Float>;
  directions?: Maybe<String>;
}

export interface ListingCreateWithoutReviewsInput {
  id?: Maybe<ID_Input>;
  title: String;
  description: String;
  maxGuests: Int;
  vendor: VendorCreateOneWithoutListingsInput;
  pricePerPlate: Int;
  views?: Maybe<ViewsCreateOneWithoutListingInput>;
  coverPhoto: String;
  bookings?: Maybe<BookingCreateManyWithoutListingInput>;
  photos?: Maybe<PictureCreateManyWithoutListingInput>;
}

export interface PaymentCreateInput {
  id?: Maybe<ID_Input>;
  serviceFee: Float;
  price: Float;
  totalPrice: Float;
  booking: BookingCreateOneWithoutPaymentInput;
  paymentMethod: PaymentAccountCreateOneWithoutPaymentsInput;
}

export interface PictureUpdateInput {
  src?: Maybe<String>;
  listing?: Maybe<ListingUpdateOneRequiredWithoutPhotosInput>;
}

export interface BookingCreateOneWithoutPaymentInput {
  create?: Maybe<BookingCreateWithoutPaymentInput>;
  connect?: Maybe<BookingWhereUniqueInput>;
}

export interface UserCreateOneInput {
  create?: Maybe<UserCreateInput>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export interface BookingCreateWithoutPaymentInput {
  id?: Maybe<ID_Input>;
  bookee: UserCreateOneInput;
  listing: ListingCreateOneWithoutBookingsInput;
  occasionDate: DateTimeInput;
  location?: Maybe<LocationCreateOneInput>;
  isFulfilled?: Maybe<Boolean>;
}

export interface ReviewCreateManyWithoutListingInput {
  create?: Maybe<
    ReviewCreateWithoutListingInput[] | ReviewCreateWithoutListingInput
  >;
  connect?: Maybe<ReviewWhereUniqueInput[] | ReviewWhereUniqueInput>;
}

export interface PaymentUpdateInput {
  serviceFee?: Maybe<Float>;
  price?: Maybe<Float>;
  totalPrice?: Maybe<Float>;
  booking?: Maybe<BookingUpdateOneRequiredWithoutPaymentInput>;
  paymentMethod?: Maybe<PaymentAccountUpdateOneRequiredWithoutPaymentsInput>;
}

export interface LocationCreateOneInput {
  create?: Maybe<LocationCreateInput>;
  connect?: Maybe<LocationWhereUniqueInput>;
}

export interface BookingUpdateOneRequiredWithoutPaymentInput {
  create?: Maybe<BookingCreateWithoutPaymentInput>;
  update?: Maybe<BookingUpdateWithoutPaymentDataInput>;
  upsert?: Maybe<BookingUpsertWithoutPaymentInput>;
  connect?: Maybe<BookingWhereUniqueInput>;
}

export interface VendorSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<VendorWhereInput>;
  AND?: Maybe<VendorSubscriptionWhereInput[] | VendorSubscriptionWhereInput>;
  OR?: Maybe<VendorSubscriptionWhereInput[] | VendorSubscriptionWhereInput>;
  NOT?: Maybe<VendorSubscriptionWhereInput[] | VendorSubscriptionWhereInput>;
}

export interface BookingUpdateWithoutPaymentDataInput {
  bookee?: Maybe<UserUpdateOneRequiredInput>;
  listing?: Maybe<ListingUpdateOneRequiredWithoutBookingsInput>;
  occasionDate?: Maybe<DateTimeInput>;
  location?: Maybe<LocationUpdateOneInput>;
  isFulfilled?: Maybe<Boolean>;
}

export type LocationWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface BookingUpsertWithoutPaymentInput {
  update: BookingUpdateWithoutPaymentDataInput;
  create: BookingCreateWithoutPaymentInput;
}

export interface ListingCreateManyWithoutVendorInput {
  create?: Maybe<
    ListingCreateWithoutVendorInput[] | ListingCreateWithoutVendorInput
  >;
  connect?: Maybe<ListingWhereUniqueInput[] | ListingWhereUniqueInput>;
}

export interface PaymentUpdateManyMutationInput {
  serviceFee?: Maybe<Float>;
  price?: Maybe<Float>;
  totalPrice?: Maybe<Float>;
}

export type ViewsWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface PaymentAccountCreateInput {
  id?: Maybe<ID_Input>;
  type?: Maybe<PAYMENT_PROVIDER>;
  user: UserCreateOneInput;
  payments?: Maybe<PaymentCreateManyWithoutPaymentMethodInput>;
}

export interface savedListCreateOneInput {
  create?: Maybe<savedListCreateInput>;
  connect?: Maybe<savedListWhereUniqueInput>;
}

export interface PaymentCreateManyWithoutPaymentMethodInput {
  create?: Maybe<
    | PaymentCreateWithoutPaymentMethodInput[]
    | PaymentCreateWithoutPaymentMethodInput
  >;
  connect?: Maybe<PaymentWhereUniqueInput[] | PaymentWhereUniqueInput>;
}

export interface PaymentCreateOneWithoutBookingInput {
  create?: Maybe<PaymentCreateWithoutBookingInput>;
  connect?: Maybe<PaymentWhereUniqueInput>;
}

export interface PaymentCreateWithoutPaymentMethodInput {
  id?: Maybe<ID_Input>;
  serviceFee: Float;
  price: Float;
  totalPrice: Float;
  booking: BookingCreateOneWithoutPaymentInput;
}

export interface ListingUpsertWithWhereUniqueWithoutVendorInput {
  where: ListingWhereUniqueInput;
  update: ListingUpdateWithoutVendorDataInput;
  create: ListingCreateWithoutVendorInput;
}

export interface PaymentUpdateWithoutPaymentMethodDataInput {
  serviceFee?: Maybe<Float>;
  price?: Maybe<Float>;
  totalPrice?: Maybe<Float>;
  booking?: Maybe<BookingUpdateOneRequiredWithoutPaymentInput>;
}

export interface PaymentUpdateWithWhereUniqueWithoutPaymentMethodInput {
  where: PaymentWhereUniqueInput;
  data: PaymentUpdateWithoutPaymentMethodDataInput;
}

export interface PaymentUpdateManyWithoutPaymentMethodInput {
  create?: Maybe<
    | PaymentCreateWithoutPaymentMethodInput[]
    | PaymentCreateWithoutPaymentMethodInput
  >;
  delete?: Maybe<PaymentWhereUniqueInput[] | PaymentWhereUniqueInput>;
  connect?: Maybe<PaymentWhereUniqueInput[] | PaymentWhereUniqueInput>;
  set?: Maybe<PaymentWhereUniqueInput[] | PaymentWhereUniqueInput>;
  disconnect?: Maybe<PaymentWhereUniqueInput[] | PaymentWhereUniqueInput>;
  update?: Maybe<
    | PaymentUpdateWithWhereUniqueWithoutPaymentMethodInput[]
    | PaymentUpdateWithWhereUniqueWithoutPaymentMethodInput
  >;
  upsert?: Maybe<
    | PaymentUpsertWithWhereUniqueWithoutPaymentMethodInput[]
    | PaymentUpsertWithWhereUniqueWithoutPaymentMethodInput
  >;
  deleteMany?: Maybe<PaymentScalarWhereInput[] | PaymentScalarWhereInput>;
  updateMany?: Maybe<
    | PaymentUpdateManyWithWhereNestedInput[]
    | PaymentUpdateManyWithWhereNestedInput
  >;
}

export interface PaymentAccountUpdateInput {
  type?: Maybe<PAYMENT_PROVIDER>;
  user?: Maybe<UserUpdateOneRequiredInput>;
  payments?: Maybe<PaymentUpdateManyWithoutPaymentMethodInput>;
}

export interface ListingUpdateWithoutReviewsDataInput {
  title?: Maybe<String>;
  description?: Maybe<String>;
  maxGuests?: Maybe<Int>;
  vendor?: Maybe<VendorUpdateOneRequiredWithoutListingsInput>;
  pricePerPlate?: Maybe<Int>;
  views?: Maybe<ViewsUpdateOneWithoutListingInput>;
  coverPhoto?: Maybe<String>;
  bookings?: Maybe<BookingUpdateManyWithoutListingInput>;
  photos?: Maybe<PictureUpdateManyWithoutListingInput>;
}

export interface LocationSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<LocationWhereInput>;
  AND?: Maybe<
    LocationSubscriptionWhereInput[] | LocationSubscriptionWhereInput
  >;
  OR?: Maybe<LocationSubscriptionWhereInput[] | LocationSubscriptionWhereInput>;
  NOT?: Maybe<
    LocationSubscriptionWhereInput[] | LocationSubscriptionWhereInput
  >;
}

export interface ViewsCreateOneWithoutListingInput {
  create?: Maybe<ViewsCreateWithoutListingInput>;
  connect?: Maybe<ViewsWhereUniqueInput>;
}

export interface PictureCreateInput {
  id?: Maybe<ID_Input>;
  src: String;
  listing: ListingCreateOneWithoutPhotosInput;
}

export interface NodeNode {
  id: ID_Output;
}

export interface savedListPreviousValues {
  id: ID_Output;
}

export interface savedListPreviousValuesPromise
  extends Promise<savedListPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
}

export interface savedListPreviousValuesSubscription
  extends Promise<AsyncIterator<savedListPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
}

export interface LocationConnection {
  pageInfo: PageInfo;
  edges: LocationEdge[];
}

export interface LocationConnectionPromise
  extends Promise<LocationConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<LocationEdge>>() => T;
  aggregate: <T = AggregateLocationPromise>() => T;
}

export interface LocationConnectionSubscription
  extends Promise<AsyncIterator<LocationConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<LocationEdgeSubscription>>>() => T;
  aggregate: <T = AggregateLocationSubscription>() => T;
}

export interface VendorPreviousValues {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  firstName: String;
  lastName: String;
  email: String;
  password: String;
  phone: String;
  profilePhoto?: String;
  offer?: String;
  vendorType?: VENDOR_TYPE;
}

export interface VendorPreviousValuesPromise
  extends Promise<VendorPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  firstName: () => Promise<String>;
  lastName: () => Promise<String>;
  email: () => Promise<String>;
  password: () => Promise<String>;
  phone: () => Promise<String>;
  profilePhoto: () => Promise<String>;
  offer: () => Promise<String>;
  vendorType: () => Promise<VENDOR_TYPE>;
}

export interface VendorPreviousValuesSubscription
  extends Promise<AsyncIterator<VendorPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  firstName: () => Promise<AsyncIterator<String>>;
  lastName: () => Promise<AsyncIterator<String>>;
  email: () => Promise<AsyncIterator<String>>;
  password: () => Promise<AsyncIterator<String>>;
  phone: () => Promise<AsyncIterator<String>>;
  profilePhoto: () => Promise<AsyncIterator<String>>;
  offer: () => Promise<AsyncIterator<String>>;
  vendorType: () => Promise<AsyncIterator<VENDOR_TYPE>>;
}

export interface savedList {
  id: ID_Output;
}

export interface savedListPromise extends Promise<savedList>, Fragmentable {
  id: () => Promise<ID_Output>;
  listings: <T = FragmentableArray<Listing>>(args?: {
    where?: ListingWhereInput;
    orderBy?: ListingOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface savedListSubscription
  extends Promise<AsyncIterator<savedList>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  listings: <T = Promise<AsyncIterator<ListingSubscription>>>(args?: {
    where?: ListingWhereInput;
    orderBy?: ListingOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface savedListNullablePromise
  extends Promise<savedList | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  listings: <T = FragmentableArray<Listing>>(args?: {
    where?: ListingWhereInput;
    orderBy?: ListingOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface ListingEdge {
  node: Listing;
  cursor: String;
}

export interface ListingEdgePromise extends Promise<ListingEdge>, Fragmentable {
  node: <T = ListingPromise>() => T;
  cursor: () => Promise<String>;
}

export interface ListingEdgeSubscription
  extends Promise<AsyncIterator<ListingEdge>>,
    Fragmentable {
  node: <T = ListingSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateListing {
  count: Int;
}

export interface AggregateListingPromise
  extends Promise<AggregateListing>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateListingSubscription
  extends Promise<AsyncIterator<AggregateListing>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface AggregatesavedList {
  count: Int;
}

export interface AggregatesavedListPromise
  extends Promise<AggregatesavedList>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregatesavedListSubscription
  extends Promise<AsyncIterator<AggregatesavedList>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface BatchPayload {
  count: Long;
}

export interface BatchPayloadPromise
  extends Promise<BatchPayload>,
    Fragmentable {
  count: () => Promise<Long>;
}

export interface BatchPayloadSubscription
  extends Promise<AsyncIterator<BatchPayload>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Long>>;
}

export interface savedListConnection {
  pageInfo: PageInfo;
  edges: savedListEdge[];
}

export interface savedListConnectionPromise
  extends Promise<savedListConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<savedListEdge>>() => T;
  aggregate: <T = AggregatesavedListPromise>() => T;
}

export interface savedListConnectionSubscription
  extends Promise<AsyncIterator<savedListConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<savedListEdgeSubscription>>>() => T;
  aggregate: <T = AggregatesavedListSubscription>() => T;
}

export interface ListingConnection {
  pageInfo: PageInfo;
  edges: ListingEdge[];
}

export interface ListingConnectionPromise
  extends Promise<ListingConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ListingEdge>>() => T;
  aggregate: <T = AggregateListingPromise>() => T;
}

export interface ListingConnectionSubscription
  extends Promise<AsyncIterator<ListingConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<ListingEdgeSubscription>>>() => T;
  aggregate: <T = AggregateListingSubscription>() => T;
}

export interface AggregateViews {
  count: Int;
}

export interface AggregateViewsPromise
  extends Promise<AggregateViews>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateViewsSubscription
  extends Promise<AsyncIterator<AggregateViews>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface AggregateBooking {
  count: Int;
}

export interface AggregateBookingPromise
  extends Promise<AggregateBooking>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateBookingSubscription
  extends Promise<AsyncIterator<AggregateBooking>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface ViewsConnection {
  pageInfo: PageInfo;
  edges: ViewsEdge[];
}

export interface ViewsConnectionPromise
  extends Promise<ViewsConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ViewsEdge>>() => T;
  aggregate: <T = AggregateViewsPromise>() => T;
}

export interface ViewsConnectionSubscription
  extends Promise<AsyncIterator<ViewsConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<ViewsEdgeSubscription>>>() => T;
  aggregate: <T = AggregateViewsSubscription>() => T;
}

export interface BookingEdge {
  node: Booking;
  cursor: String;
}

export interface BookingEdgePromise extends Promise<BookingEdge>, Fragmentable {
  node: <T = BookingPromise>() => T;
  cursor: () => Promise<String>;
}

export interface BookingEdgeSubscription
  extends Promise<AsyncIterator<BookingEdge>>,
    Fragmentable {
  node: <T = BookingSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateVendor {
  count: Int;
}

export interface AggregateVendorPromise
  extends Promise<AggregateVendor>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateVendorSubscription
  extends Promise<AsyncIterator<AggregateVendor>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface Booking {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  occasionDate: DateTimeOutput;
  isFulfilled?: Boolean;
}

export interface BookingPromise extends Promise<Booking>, Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  bookee: <T = UserPromise>() => T;
  listing: <T = ListingPromise>() => T;
  occasionDate: () => Promise<DateTimeOutput>;
  location: <T = LocationPromise>() => T;
  payment: <T = PaymentPromise>() => T;
  isFulfilled: () => Promise<Boolean>;
}

export interface BookingSubscription
  extends Promise<AsyncIterator<Booking>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  bookee: <T = UserSubscription>() => T;
  listing: <T = ListingSubscription>() => T;
  occasionDate: () => Promise<AsyncIterator<DateTimeOutput>>;
  location: <T = LocationSubscription>() => T;
  payment: <T = PaymentSubscription>() => T;
  isFulfilled: () => Promise<AsyncIterator<Boolean>>;
}

export interface BookingNullablePromise
  extends Promise<Booking | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  bookee: <T = UserPromise>() => T;
  listing: <T = ListingPromise>() => T;
  occasionDate: () => Promise<DateTimeOutput>;
  location: <T = LocationPromise>() => T;
  payment: <T = PaymentPromise>() => T;
  isFulfilled: () => Promise<Boolean>;
}

export interface VendorConnection {
  pageInfo: PageInfo;
  edges: VendorEdge[];
}

export interface VendorConnectionPromise
  extends Promise<VendorConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<VendorEdge>>() => T;
  aggregate: <T = AggregateVendorPromise>() => T;
}

export interface VendorConnectionSubscription
  extends Promise<AsyncIterator<VendorConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<VendorEdgeSubscription>>>() => T;
  aggregate: <T = AggregateVendorSubscription>() => T;
}

export interface BookingSubscriptionPayload {
  mutation: MutationType;
  node: Booking;
  updatedFields: String[];
  previousValues: BookingPreviousValues;
}

export interface BookingSubscriptionPayloadPromise
  extends Promise<BookingSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = BookingPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = BookingPreviousValuesPromise>() => T;
}

export interface BookingSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<BookingSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = BookingSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = BookingPreviousValuesSubscription>() => T;
}

export interface AggregateUser {
  count: Int;
}

export interface AggregateUserPromise
  extends Promise<AggregateUser>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateUserSubscription
  extends Promise<AsyncIterator<AggregateUser>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface BookingPreviousValues {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  occasionDate: DateTimeOutput;
  isFulfilled?: Boolean;
}

export interface BookingPreviousValuesPromise
  extends Promise<BookingPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  occasionDate: () => Promise<DateTimeOutput>;
  isFulfilled: () => Promise<Boolean>;
}

export interface BookingPreviousValuesSubscription
  extends Promise<AsyncIterator<BookingPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  occasionDate: () => Promise<AsyncIterator<DateTimeOutput>>;
  isFulfilled: () => Promise<AsyncIterator<Boolean>>;
}

export interface UserConnection {
  pageInfo: PageInfo;
  edges: UserEdge[];
}

export interface UserConnectionPromise
  extends Promise<UserConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<UserEdge>>() => T;
  aggregate: <T = AggregateUserPromise>() => T;
}

export interface UserConnectionSubscription
  extends Promise<AsyncIterator<UserConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<UserEdgeSubscription>>>() => T;
  aggregate: <T = AggregateUserSubscription>() => T;
}

export interface PageInfo {
  hasNextPage: Boolean;
  hasPreviousPage: Boolean;
  startCursor?: String;
  endCursor?: String;
}

export interface PageInfoPromise extends Promise<PageInfo>, Fragmentable {
  hasNextPage: () => Promise<Boolean>;
  hasPreviousPage: () => Promise<Boolean>;
  startCursor: () => Promise<String>;
  endCursor: () => Promise<String>;
}

export interface PageInfoSubscription
  extends Promise<AsyncIterator<PageInfo>>,
    Fragmentable {
  hasNextPage: () => Promise<AsyncIterator<Boolean>>;
  hasPreviousPage: () => Promise<AsyncIterator<Boolean>>;
  startCursor: () => Promise<AsyncIterator<String>>;
  endCursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateReview {
  count: Int;
}

export interface AggregateReviewPromise
  extends Promise<AggregateReview>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateReviewSubscription
  extends Promise<AsyncIterator<AggregateReview>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface ListingSubscriptionPayload {
  mutation: MutationType;
  node: Listing;
  updatedFields: String[];
  previousValues: ListingPreviousValues;
}

export interface ListingSubscriptionPayloadPromise
  extends Promise<ListingSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ListingPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ListingPreviousValuesPromise>() => T;
}

export interface ListingSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ListingSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ListingSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ListingPreviousValuesSubscription>() => T;
}

export interface ReviewConnection {
  pageInfo: PageInfo;
  edges: ReviewEdge[];
}

export interface ReviewConnectionPromise
  extends Promise<ReviewConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ReviewEdge>>() => T;
  aggregate: <T = AggregateReviewPromise>() => T;
}

export interface ReviewConnectionSubscription
  extends Promise<AsyncIterator<ReviewConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<ReviewEdgeSubscription>>>() => T;
  aggregate: <T = AggregateReviewSubscription>() => T;
}

export interface ListingPreviousValues {
  id: ID_Output;
  title: String;
  description: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  maxGuests: Int;
  pricePerPlate: Int;
  coverPhoto: String;
}

export interface ListingPreviousValuesPromise
  extends Promise<ListingPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  title: () => Promise<String>;
  description: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  maxGuests: () => Promise<Int>;
  pricePerPlate: () => Promise<Int>;
  coverPhoto: () => Promise<String>;
}

export interface ListingPreviousValuesSubscription
  extends Promise<AsyncIterator<ListingPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  title: () => Promise<AsyncIterator<String>>;
  description: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  maxGuests: () => Promise<AsyncIterator<Int>>;
  pricePerPlate: () => Promise<AsyncIterator<Int>>;
  coverPhoto: () => Promise<AsyncIterator<String>>;
}

export interface PictureEdge {
  node: Picture;
  cursor: String;
}

export interface PictureEdgePromise extends Promise<PictureEdge>, Fragmentable {
  node: <T = PicturePromise>() => T;
  cursor: () => Promise<String>;
}

export interface PictureEdgeSubscription
  extends Promise<AsyncIterator<PictureEdge>>,
    Fragmentable {
  node: <T = PictureSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface BookingConnection {
  pageInfo: PageInfo;
  edges: BookingEdge[];
}

export interface BookingConnectionPromise
  extends Promise<BookingConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<BookingEdge>>() => T;
  aggregate: <T = AggregateBookingPromise>() => T;
}

export interface BookingConnectionSubscription
  extends Promise<AsyncIterator<BookingConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<BookingEdgeSubscription>>>() => T;
  aggregate: <T = AggregateBookingSubscription>() => T;
}

export interface AggregatePaymentAccount {
  count: Int;
}

export interface AggregatePaymentAccountPromise
  extends Promise<AggregatePaymentAccount>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregatePaymentAccountSubscription
  extends Promise<AsyncIterator<AggregatePaymentAccount>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface LocationSubscriptionPayload {
  mutation: MutationType;
  node: Location;
  updatedFields: String[];
  previousValues: LocationPreviousValues;
}

export interface LocationSubscriptionPayloadPromise
  extends Promise<LocationSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = LocationPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = LocationPreviousValuesPromise>() => T;
}

export interface LocationSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<LocationSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = LocationSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = LocationPreviousValuesSubscription>() => T;
}

export interface PaymentAccountConnection {
  pageInfo: PageInfo;
  edges: PaymentAccountEdge[];
}

export interface PaymentAccountConnectionPromise
  extends Promise<PaymentAccountConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<PaymentAccountEdge>>() => T;
  aggregate: <T = AggregatePaymentAccountPromise>() => T;
}

export interface PaymentAccountConnectionSubscription
  extends Promise<AsyncIterator<PaymentAccountConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<PaymentAccountEdgeSubscription>>>() => T;
  aggregate: <T = AggregatePaymentAccountSubscription>() => T;
}

export interface LocationPreviousValues {
  id: ID_Output;
  lat: Float;
  lng: Float;
  directions: String;
}

export interface LocationPreviousValuesPromise
  extends Promise<LocationPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  lat: () => Promise<Float>;
  lng: () => Promise<Float>;
  directions: () => Promise<String>;
}

export interface LocationPreviousValuesSubscription
  extends Promise<AsyncIterator<LocationPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  lat: () => Promise<AsyncIterator<Float>>;
  lng: () => Promise<AsyncIterator<Float>>;
  directions: () => Promise<AsyncIterator<String>>;
}

export interface AggregatePayment {
  count: Int;
}

export interface AggregatePaymentPromise
  extends Promise<AggregatePayment>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregatePaymentSubscription
  extends Promise<AsyncIterator<AggregatePayment>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface PaymentAccount {
  id: ID_Output;
  createdAt: DateTimeOutput;
  type?: PAYMENT_PROVIDER;
}

export interface PaymentAccountPromise
  extends Promise<PaymentAccount>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  type: () => Promise<PAYMENT_PROVIDER>;
  user: <T = UserPromise>() => T;
  payments: <T = FragmentableArray<Payment>>(args?: {
    where?: PaymentWhereInput;
    orderBy?: PaymentOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface PaymentAccountSubscription
  extends Promise<AsyncIterator<PaymentAccount>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  type: () => Promise<AsyncIterator<PAYMENT_PROVIDER>>;
  user: <T = UserSubscription>() => T;
  payments: <T = Promise<AsyncIterator<PaymentSubscription>>>(args?: {
    where?: PaymentWhereInput;
    orderBy?: PaymentOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface PaymentAccountNullablePromise
  extends Promise<PaymentAccount | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  type: () => Promise<PAYMENT_PROVIDER>;
  user: <T = UserPromise>() => T;
  payments: <T = FragmentableArray<Payment>>(args?: {
    where?: PaymentWhereInput;
    orderBy?: PaymentOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface PaymentConnection {
  pageInfo: PageInfo;
  edges: PaymentEdge[];
}

export interface PaymentConnectionPromise
  extends Promise<PaymentConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<PaymentEdge>>() => T;
  aggregate: <T = AggregatePaymentPromise>() => T;
}

export interface PaymentConnectionSubscription
  extends Promise<AsyncIterator<PaymentConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<PaymentEdgeSubscription>>>() => T;
  aggregate: <T = AggregatePaymentSubscription>() => T;
}

export interface PaymentSubscriptionPayload {
  mutation: MutationType;
  node: Payment;
  updatedFields: String[];
  previousValues: PaymentPreviousValues;
}

export interface PaymentSubscriptionPayloadPromise
  extends Promise<PaymentSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = PaymentPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = PaymentPreviousValuesPromise>() => T;
}

export interface PaymentSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<PaymentSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = PaymentSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = PaymentPreviousValuesSubscription>() => T;
}

export interface LocationEdge {
  node: Location;
  cursor: String;
}

export interface LocationEdgePromise
  extends Promise<LocationEdge>,
    Fragmentable {
  node: <T = LocationPromise>() => T;
  cursor: () => Promise<String>;
}

export interface LocationEdgeSubscription
  extends Promise<AsyncIterator<LocationEdge>>,
    Fragmentable {
  node: <T = LocationSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface PaymentPreviousValues {
  id: ID_Output;
  createdAt: DateTimeOutput;
  serviceFee: Float;
  price: Float;
  totalPrice: Float;
}

export interface PaymentPreviousValuesPromise
  extends Promise<PaymentPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  serviceFee: () => Promise<Float>;
  price: () => Promise<Float>;
  totalPrice: () => Promise<Float>;
}

export interface PaymentPreviousValuesSubscription
  extends Promise<AsyncIterator<PaymentPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  serviceFee: () => Promise<AsyncIterator<Float>>;
  price: () => Promise<AsyncIterator<Float>>;
  totalPrice: () => Promise<AsyncIterator<Float>>;
}

export interface savedListEdge {
  node: savedList;
  cursor: String;
}

export interface savedListEdgePromise
  extends Promise<savedListEdge>,
    Fragmentable {
  node: <T = savedListPromise>() => T;
  cursor: () => Promise<String>;
}

export interface savedListEdgeSubscription
  extends Promise<AsyncIterator<savedListEdge>>,
    Fragmentable {
  node: <T = savedListSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface Payment {
  id: ID_Output;
  createdAt: DateTimeOutput;
  serviceFee: Float;
  price: Float;
  totalPrice: Float;
}

export interface PaymentPromise extends Promise<Payment>, Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  serviceFee: () => Promise<Float>;
  price: () => Promise<Float>;
  totalPrice: () => Promise<Float>;
  booking: <T = BookingPromise>() => T;
  paymentMethod: <T = PaymentAccountPromise>() => T;
}

export interface PaymentSubscription
  extends Promise<AsyncIterator<Payment>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  serviceFee: () => Promise<AsyncIterator<Float>>;
  price: () => Promise<AsyncIterator<Float>>;
  totalPrice: () => Promise<AsyncIterator<Float>>;
  booking: <T = BookingSubscription>() => T;
  paymentMethod: <T = PaymentAccountSubscription>() => T;
}

export interface PaymentNullablePromise
  extends Promise<Payment | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  serviceFee: () => Promise<Float>;
  price: () => Promise<Float>;
  totalPrice: () => Promise<Float>;
  booking: <T = BookingPromise>() => T;
  paymentMethod: <T = PaymentAccountPromise>() => T;
}

export interface ViewsEdge {
  node: Views;
  cursor: String;
}

export interface ViewsEdgePromise extends Promise<ViewsEdge>, Fragmentable {
  node: <T = ViewsPromise>() => T;
  cursor: () => Promise<String>;
}

export interface ViewsEdgeSubscription
  extends Promise<AsyncIterator<ViewsEdge>>,
    Fragmentable {
  node: <T = ViewsSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface PaymentAccountSubscriptionPayload {
  mutation: MutationType;
  node: PaymentAccount;
  updatedFields: String[];
  previousValues: PaymentAccountPreviousValues;
}

export interface PaymentAccountSubscriptionPayloadPromise
  extends Promise<PaymentAccountSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = PaymentAccountPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = PaymentAccountPreviousValuesPromise>() => T;
}

export interface PaymentAccountSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<PaymentAccountSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = PaymentAccountSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = PaymentAccountPreviousValuesSubscription>() => T;
}

export interface VendorEdge {
  node: Vendor;
  cursor: String;
}

export interface VendorEdgePromise extends Promise<VendorEdge>, Fragmentable {
  node: <T = VendorPromise>() => T;
  cursor: () => Promise<String>;
}

export interface VendorEdgeSubscription
  extends Promise<AsyncIterator<VendorEdge>>,
    Fragmentable {
  node: <T = VendorSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface PaymentAccountPreviousValues {
  id: ID_Output;
  createdAt: DateTimeOutput;
  type?: PAYMENT_PROVIDER;
}

export interface PaymentAccountPreviousValuesPromise
  extends Promise<PaymentAccountPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  type: () => Promise<PAYMENT_PROVIDER>;
}

export interface PaymentAccountPreviousValuesSubscription
  extends Promise<AsyncIterator<PaymentAccountPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  type: () => Promise<AsyncIterator<PAYMENT_PROVIDER>>;
}

export interface UserEdge {
  node: User;
  cursor: String;
}

export interface UserEdgePromise extends Promise<UserEdge>, Fragmentable {
  node: <T = UserPromise>() => T;
  cursor: () => Promise<String>;
}

export interface UserEdgeSubscription
  extends Promise<AsyncIterator<UserEdge>>,
    Fragmentable {
  node: <T = UserSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface Picture {
  id: ID_Output;
  src: String;
}

export interface PicturePromise extends Promise<Picture>, Fragmentable {
  id: () => Promise<ID_Output>;
  src: () => Promise<String>;
  listing: <T = ListingPromise>() => T;
}

export interface PictureSubscription
  extends Promise<AsyncIterator<Picture>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  src: () => Promise<AsyncIterator<String>>;
  listing: <T = ListingSubscription>() => T;
}

export interface PictureNullablePromise
  extends Promise<Picture | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  src: () => Promise<String>;
  listing: <T = ListingPromise>() => T;
}

export interface ReviewEdge {
  node: Review;
  cursor: String;
}

export interface ReviewEdgePromise extends Promise<ReviewEdge>, Fragmentable {
  node: <T = ReviewPromise>() => T;
  cursor: () => Promise<String>;
}

export interface ReviewEdgeSubscription
  extends Promise<AsyncIterator<ReviewEdge>>,
    Fragmentable {
  node: <T = ReviewSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface PictureSubscriptionPayload {
  mutation: MutationType;
  node: Picture;
  updatedFields: String[];
  previousValues: PicturePreviousValues;
}

export interface PictureSubscriptionPayloadPromise
  extends Promise<PictureSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = PicturePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = PicturePreviousValuesPromise>() => T;
}

export interface PictureSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<PictureSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = PictureSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = PicturePreviousValuesSubscription>() => T;
}

export interface PictureConnection {
  pageInfo: PageInfo;
  edges: PictureEdge[];
}

export interface PictureConnectionPromise
  extends Promise<PictureConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<PictureEdge>>() => T;
  aggregate: <T = AggregatePicturePromise>() => T;
}

export interface PictureConnectionSubscription
  extends Promise<AsyncIterator<PictureConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<PictureEdgeSubscription>>>() => T;
  aggregate: <T = AggregatePictureSubscription>() => T;
}

export interface PicturePreviousValues {
  id: ID_Output;
  src: String;
}

export interface PicturePreviousValuesPromise
  extends Promise<PicturePreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  src: () => Promise<String>;
}

export interface PicturePreviousValuesSubscription
  extends Promise<AsyncIterator<PicturePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  src: () => Promise<AsyncIterator<String>>;
}

export interface ViewsSubscriptionPayload {
  mutation: MutationType;
  node: Views;
  updatedFields: String[];
  previousValues: ViewsPreviousValues;
}

export interface ViewsSubscriptionPayloadPromise
  extends Promise<ViewsSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ViewsPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ViewsPreviousValuesPromise>() => T;
}

export interface ViewsSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ViewsSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ViewsSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ViewsPreviousValuesSubscription>() => T;
}

export interface Review {
  id: ID_Output;
  createdAt: DateTimeOutput;
  title: String;
  comment: String;
  stars: Int;
}

export interface ReviewPromise extends Promise<Review>, Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  title: () => Promise<String>;
  comment: () => Promise<String>;
  stars: () => Promise<Int>;
  listing: <T = ListingPromise>() => T;
}

export interface ReviewSubscription
  extends Promise<AsyncIterator<Review>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  title: () => Promise<AsyncIterator<String>>;
  comment: () => Promise<AsyncIterator<String>>;
  stars: () => Promise<AsyncIterator<Int>>;
  listing: <T = ListingSubscription>() => T;
}

export interface ReviewNullablePromise
  extends Promise<Review | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  title: () => Promise<String>;
  comment: () => Promise<String>;
  stars: () => Promise<Int>;
  listing: <T = ListingPromise>() => T;
}

export interface AggregateLocation {
  count: Int;
}

export interface AggregateLocationPromise
  extends Promise<AggregateLocation>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateLocationSubscription
  extends Promise<AsyncIterator<AggregateLocation>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface ReviewSubscriptionPayload {
  mutation: MutationType;
  node: Review;
  updatedFields: String[];
  previousValues: ReviewPreviousValues;
}

export interface ReviewSubscriptionPayloadPromise
  extends Promise<ReviewSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ReviewPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ReviewPreviousValuesPromise>() => T;
}

export interface ReviewSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ReviewSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ReviewSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ReviewPreviousValuesSubscription>() => T;
}

export interface Listing {
  id: ID_Output;
  title: String;
  description: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  maxGuests: Int;
  pricePerPlate: Int;
  coverPhoto: String;
}

export interface ListingPromise extends Promise<Listing>, Fragmentable {
  id: () => Promise<ID_Output>;
  title: () => Promise<String>;
  description: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  maxGuests: () => Promise<Int>;
  reviews: <T = FragmentableArray<Review>>(args?: {
    where?: ReviewWhereInput;
    orderBy?: ReviewOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  vendor: <T = VendorPromise>() => T;
  pricePerPlate: () => Promise<Int>;
  views: <T = ViewsPromise>() => T;
  coverPhoto: () => Promise<String>;
  bookings: <T = FragmentableArray<Booking>>(args?: {
    where?: BookingWhereInput;
    orderBy?: BookingOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  photos: <T = FragmentableArray<Picture>>(args?: {
    where?: PictureWhereInput;
    orderBy?: PictureOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface ListingSubscription
  extends Promise<AsyncIterator<Listing>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  title: () => Promise<AsyncIterator<String>>;
  description: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  maxGuests: () => Promise<AsyncIterator<Int>>;
  reviews: <T = Promise<AsyncIterator<ReviewSubscription>>>(args?: {
    where?: ReviewWhereInput;
    orderBy?: ReviewOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  vendor: <T = VendorSubscription>() => T;
  pricePerPlate: () => Promise<AsyncIterator<Int>>;
  views: <T = ViewsSubscription>() => T;
  coverPhoto: () => Promise<AsyncIterator<String>>;
  bookings: <T = Promise<AsyncIterator<BookingSubscription>>>(args?: {
    where?: BookingWhereInput;
    orderBy?: BookingOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  photos: <T = Promise<AsyncIterator<PictureSubscription>>>(args?: {
    where?: PictureWhereInput;
    orderBy?: PictureOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface ListingNullablePromise
  extends Promise<Listing | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  title: () => Promise<String>;
  description: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  maxGuests: () => Promise<Int>;
  reviews: <T = FragmentableArray<Review>>(args?: {
    where?: ReviewWhereInput;
    orderBy?: ReviewOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  vendor: <T = VendorPromise>() => T;
  pricePerPlate: () => Promise<Int>;
  views: <T = ViewsPromise>() => T;
  coverPhoto: () => Promise<String>;
  bookings: <T = FragmentableArray<Booking>>(args?: {
    where?: BookingWhereInput;
    orderBy?: BookingOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  photos: <T = FragmentableArray<Picture>>(args?: {
    where?: PictureWhereInput;
    orderBy?: PictureOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface ReviewPreviousValues {
  id: ID_Output;
  createdAt: DateTimeOutput;
  title: String;
  comment: String;
  stars: Int;
}

export interface ReviewPreviousValuesPromise
  extends Promise<ReviewPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  title: () => Promise<String>;
  comment: () => Promise<String>;
  stars: () => Promise<Int>;
}

export interface ReviewPreviousValuesSubscription
  extends Promise<AsyncIterator<ReviewPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  title: () => Promise<AsyncIterator<String>>;
  comment: () => Promise<AsyncIterator<String>>;
  stars: () => Promise<AsyncIterator<Int>>;
}

export interface ViewsPreviousValues {
  id: ID_Output;
  lastWeek: Int;
}

export interface ViewsPreviousValuesPromise
  extends Promise<ViewsPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  lastWeek: () => Promise<Int>;
}

export interface ViewsPreviousValuesSubscription
  extends Promise<AsyncIterator<ViewsPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  lastWeek: () => Promise<AsyncIterator<Int>>;
}

export interface Views {
  id: ID_Output;
  lastWeek: Int;
}

export interface ViewsPromise extends Promise<Views>, Fragmentable {
  id: () => Promise<ID_Output>;
  lastWeek: () => Promise<Int>;
  listing: <T = ListingPromise>() => T;
}

export interface ViewsSubscription
  extends Promise<AsyncIterator<Views>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  lastWeek: () => Promise<AsyncIterator<Int>>;
  listing: <T = ListingSubscription>() => T;
}

export interface ViewsNullablePromise
  extends Promise<Views | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  lastWeek: () => Promise<Int>;
  listing: <T = ListingPromise>() => T;
}

export interface AggregatePicture {
  count: Int;
}

export interface AggregatePicturePromise
  extends Promise<AggregatePicture>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregatePictureSubscription
  extends Promise<AsyncIterator<AggregatePicture>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface PaymentEdge {
  node: Payment;
  cursor: String;
}

export interface PaymentEdgePromise extends Promise<PaymentEdge>, Fragmentable {
  node: <T = PaymentPromise>() => T;
  cursor: () => Promise<String>;
}

export interface PaymentEdgeSubscription
  extends Promise<AsyncIterator<PaymentEdge>>,
    Fragmentable {
  node: <T = PaymentSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface VendorSubscriptionPayload {
  mutation: MutationType;
  node: Vendor;
  updatedFields: String[];
  previousValues: VendorPreviousValues;
}

export interface VendorSubscriptionPayloadPromise
  extends Promise<VendorSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = VendorPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = VendorPreviousValuesPromise>() => T;
}

export interface VendorSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<VendorSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = VendorSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = VendorPreviousValuesSubscription>() => T;
}

export interface Vendor {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  firstName: String;
  lastName: String;
  email: String;
  password: String;
  phone: String;
  profilePhoto?: String;
  offer?: String;
  vendorType?: VENDOR_TYPE;
}

export interface VendorPromise extends Promise<Vendor>, Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  firstName: () => Promise<String>;
  lastName: () => Promise<String>;
  email: () => Promise<String>;
  password: () => Promise<String>;
  phone: () => Promise<String>;
  profilePhoto: () => Promise<String>;
  offer: () => Promise<String>;
  listings: <T = FragmentableArray<Listing>>(args?: {
    where?: ListingWhereInput;
    orderBy?: ListingOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  vendorType: () => Promise<VENDOR_TYPE>;
}

export interface VendorSubscription
  extends Promise<AsyncIterator<Vendor>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  firstName: () => Promise<AsyncIterator<String>>;
  lastName: () => Promise<AsyncIterator<String>>;
  email: () => Promise<AsyncIterator<String>>;
  password: () => Promise<AsyncIterator<String>>;
  phone: () => Promise<AsyncIterator<String>>;
  profilePhoto: () => Promise<AsyncIterator<String>>;
  offer: () => Promise<AsyncIterator<String>>;
  listings: <T = Promise<AsyncIterator<ListingSubscription>>>(args?: {
    where?: ListingWhereInput;
    orderBy?: ListingOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  vendorType: () => Promise<AsyncIterator<VENDOR_TYPE>>;
}

export interface VendorNullablePromise
  extends Promise<Vendor | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  firstName: () => Promise<String>;
  lastName: () => Promise<String>;
  email: () => Promise<String>;
  password: () => Promise<String>;
  phone: () => Promise<String>;
  profilePhoto: () => Promise<String>;
  offer: () => Promise<String>;
  listings: <T = FragmentableArray<Listing>>(args?: {
    where?: ListingWhereInput;
    orderBy?: ListingOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  vendorType: () => Promise<VENDOR_TYPE>;
}

export interface UserPreviousValues {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  email: String;
  firstName: String;
  phone?: String;
  password: String;
  lastName: String;
  photoUrl?: String;
}

export interface UserPreviousValuesPromise
  extends Promise<UserPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  email: () => Promise<String>;
  firstName: () => Promise<String>;
  phone: () => Promise<String>;
  password: () => Promise<String>;
  lastName: () => Promise<String>;
  photoUrl: () => Promise<String>;
}

export interface UserPreviousValuesSubscription
  extends Promise<AsyncIterator<UserPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  email: () => Promise<AsyncIterator<String>>;
  firstName: () => Promise<AsyncIterator<String>>;
  phone: () => Promise<AsyncIterator<String>>;
  password: () => Promise<AsyncIterator<String>>;
  lastName: () => Promise<AsyncIterator<String>>;
  photoUrl: () => Promise<AsyncIterator<String>>;
}

export interface UserSubscriptionPayload {
  mutation: MutationType;
  node: User;
  updatedFields: String[];
  previousValues: UserPreviousValues;
}

export interface UserSubscriptionPayloadPromise
  extends Promise<UserSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = UserPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = UserPreviousValuesPromise>() => T;
}

export interface UserSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<UserSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = UserSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = UserPreviousValuesSubscription>() => T;
}

export interface savedListSubscriptionPayload {
  mutation: MutationType;
  node: savedList;
  updatedFields: String[];
  previousValues: savedListPreviousValues;
}

export interface savedListSubscriptionPayloadPromise
  extends Promise<savedListSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = savedListPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = savedListPreviousValuesPromise>() => T;
}

export interface savedListSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<savedListSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = savedListSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = savedListPreviousValuesSubscription>() => T;
}

export interface PaymentAccountEdge {
  node: PaymentAccount;
  cursor: String;
}

export interface PaymentAccountEdgePromise
  extends Promise<PaymentAccountEdge>,
    Fragmentable {
  node: <T = PaymentAccountPromise>() => T;
  cursor: () => Promise<String>;
}

export interface PaymentAccountEdgeSubscription
  extends Promise<AsyncIterator<PaymentAccountEdge>>,
    Fragmentable {
  node: <T = PaymentAccountSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface Location {
  id: ID_Output;
  lat: Float;
  lng: Float;
  directions: String;
}

export interface LocationPromise extends Promise<Location>, Fragmentable {
  id: () => Promise<ID_Output>;
  lat: () => Promise<Float>;
  lng: () => Promise<Float>;
  user: <T = UserPromise>() => T;
  directions: () => Promise<String>;
}

export interface LocationSubscription
  extends Promise<AsyncIterator<Location>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  lat: () => Promise<AsyncIterator<Float>>;
  lng: () => Promise<AsyncIterator<Float>>;
  user: <T = UserSubscription>() => T;
  directions: () => Promise<AsyncIterator<String>>;
}

export interface LocationNullablePromise
  extends Promise<Location | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  lat: () => Promise<Float>;
  lng: () => Promise<Float>;
  user: <T = UserPromise>() => T;
  directions: () => Promise<String>;
}

export interface User {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  email: String;
  firstName: String;
  phone?: String;
  password: String;
  lastName: String;
  photoUrl?: String;
}

export interface UserPromise extends Promise<User>, Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  email: () => Promise<String>;
  firstName: () => Promise<String>;
  phone: () => Promise<String>;
  password: () => Promise<String>;
  lastName: () => Promise<String>;
  address: <T = LocationPromise>() => T;
  saved: <T = savedListPromise>() => T;
  photoUrl: () => Promise<String>;
}

export interface UserSubscription
  extends Promise<AsyncIterator<User>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  email: () => Promise<AsyncIterator<String>>;
  firstName: () => Promise<AsyncIterator<String>>;
  phone: () => Promise<AsyncIterator<String>>;
  password: () => Promise<AsyncIterator<String>>;
  lastName: () => Promise<AsyncIterator<String>>;
  address: <T = LocationSubscription>() => T;
  saved: <T = savedListSubscription>() => T;
  photoUrl: () => Promise<AsyncIterator<String>>;
}

export interface UserNullablePromise
  extends Promise<User | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  email: () => Promise<String>;
  firstName: () => Promise<String>;
  phone: () => Promise<String>;
  password: () => Promise<String>;
  lastName: () => Promise<String>;
  address: <T = LocationPromise>() => T;
  saved: <T = savedListPromise>() => T;
  photoUrl: () => Promise<String>;
}

/*
The `Boolean` scalar type represents `true` or `false`.
*/
export type Boolean = boolean;

export type Long = string;

/*
The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as `"4"`) or integer (such as `4`) input value will be accepted as an ID.
*/
export type ID_Input = string | number;
export type ID_Output = string;

/*
DateTime scalar input type, allowing Date
*/
export type DateTimeInput = Date | string;

/*
DateTime scalar output type, which is always a string
*/
export type DateTimeOutput = string;

/*
The `String` scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.
*/
export type String = string;

/*
The `Float` scalar type represents signed double-precision fractional values as specified by [IEEE 754](https://en.wikipedia.org/wiki/IEEE_floating_point).
*/
export type Float = number;

/*
The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1.
*/
export type Int = number;

/**
 * Model Metadata
 */

export const models: Model[] = [
  {
    name: "Vendor",
    embedded: false
  },
  {
    name: "User",
    embedded: false
  },
  {
    name: "Location",
    embedded: false
  },
  {
    name: "Listing",
    embedded: false
  },
  {
    name: "Picture",
    embedded: false
  },
  {
    name: "Views",
    embedded: false
  },
  {
    name: "Review",
    embedded: false
  },
  {
    name: "Booking",
    embedded: false
  },
  {
    name: "Payment",
    embedded: false
  },
  {
    name: "PaymentAccount",
    embedded: false
  },
  {
    name: "savedList",
    embedded: false
  },
  {
    name: "PAYMENT_PROVIDER",
    embedded: false
  },
  {
    name: "VENDOR_TYPE",
    embedded: false
  }
];

/**
 * Type Defs
 */

export const Prisma = makePrismaClientClass<ClientConstructor<Prisma>>({
  typeDefs,
  models,
  endpoint: `http://localhost:4466`
});
export const prisma = new Prisma();
