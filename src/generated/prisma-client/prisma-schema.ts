// Code generated by Prisma (prisma@1.34.3). DO NOT EDIT.
  // Please don't change this file manually but run `prisma generate` to update it.
  // For more information, please read the docs: https://www.prisma.io/docs/prisma-client/

export const typeDefs = /* GraphQL */ `type AggregateBooking {
  count: Int!
}

type AggregateListing {
  count: Int!
}

type AggregateLocation {
  count: Int!
}

type AggregatePayment {
  count: Int!
}

type AggregatePaymentAccount {
  count: Int!
}

type AggregatePicture {
  count: Int!
}

type AggregateReview {
  count: Int!
}

type AggregatesavedList {
  count: Int!
}

type AggregateUser {
  count: Int!
}

type AggregateVendor {
  count: Int!
}

type AggregateViews {
  count: Int!
}

type BatchPayload {
  count: Long!
}

type Booking {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  bookee: User!
  listing: Listing!
  occasionDate: DateTime!
  location: Location
  payment: Payment
  isFulfilled: Boolean
}

type BookingConnection {
  pageInfo: PageInfo!
  edges: [BookingEdge]!
  aggregate: AggregateBooking!
}

input BookingCreateInput {
  id: ID
  bookee: UserCreateOneInput!
  listing: ListingCreateOneWithoutBookingsInput!
  occasionDate: DateTime!
  location: LocationCreateOneInput
  payment: PaymentCreateOneWithoutBookingInput
  isFulfilled: Boolean
}

input BookingCreateManyWithoutListingInput {
  create: [BookingCreateWithoutListingInput!]
  connect: [BookingWhereUniqueInput!]
}

input BookingCreateOneWithoutPaymentInput {
  create: BookingCreateWithoutPaymentInput
  connect: BookingWhereUniqueInput
}

input BookingCreateWithoutListingInput {
  id: ID
  bookee: UserCreateOneInput!
  occasionDate: DateTime!
  location: LocationCreateOneInput
  payment: PaymentCreateOneWithoutBookingInput
  isFulfilled: Boolean
}

input BookingCreateWithoutPaymentInput {
  id: ID
  bookee: UserCreateOneInput!
  listing: ListingCreateOneWithoutBookingsInput!
  occasionDate: DateTime!
  location: LocationCreateOneInput
  isFulfilled: Boolean
}

type BookingEdge {
  node: Booking!
  cursor: String!
}

enum BookingOrderByInput {
  id_ASC
  id_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
  occasionDate_ASC
  occasionDate_DESC
  isFulfilled_ASC
  isFulfilled_DESC
}

type BookingPreviousValues {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  occasionDate: DateTime!
  isFulfilled: Boolean
}

input BookingScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  occasionDate: DateTime
  occasionDate_not: DateTime
  occasionDate_in: [DateTime!]
  occasionDate_not_in: [DateTime!]
  occasionDate_lt: DateTime
  occasionDate_lte: DateTime
  occasionDate_gt: DateTime
  occasionDate_gte: DateTime
  isFulfilled: Boolean
  isFulfilled_not: Boolean
  AND: [BookingScalarWhereInput!]
  OR: [BookingScalarWhereInput!]
  NOT: [BookingScalarWhereInput!]
}

type BookingSubscriptionPayload {
  mutation: MutationType!
  node: Booking
  updatedFields: [String!]
  previousValues: BookingPreviousValues
}

input BookingSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: BookingWhereInput
  AND: [BookingSubscriptionWhereInput!]
  OR: [BookingSubscriptionWhereInput!]
  NOT: [BookingSubscriptionWhereInput!]
}

input BookingUpdateInput {
  bookee: UserUpdateOneRequiredInput
  listing: ListingUpdateOneRequiredWithoutBookingsInput
  occasionDate: DateTime
  location: LocationUpdateOneInput
  payment: PaymentUpdateOneWithoutBookingInput
  isFulfilled: Boolean
}

input BookingUpdateManyDataInput {
  occasionDate: DateTime
  isFulfilled: Boolean
}

input BookingUpdateManyMutationInput {
  occasionDate: DateTime
  isFulfilled: Boolean
}

input BookingUpdateManyWithoutListingInput {
  create: [BookingCreateWithoutListingInput!]
  delete: [BookingWhereUniqueInput!]
  connect: [BookingWhereUniqueInput!]
  set: [BookingWhereUniqueInput!]
  disconnect: [BookingWhereUniqueInput!]
  update: [BookingUpdateWithWhereUniqueWithoutListingInput!]
  upsert: [BookingUpsertWithWhereUniqueWithoutListingInput!]
  deleteMany: [BookingScalarWhereInput!]
  updateMany: [BookingUpdateManyWithWhereNestedInput!]
}

input BookingUpdateManyWithWhereNestedInput {
  where: BookingScalarWhereInput!
  data: BookingUpdateManyDataInput!
}

input BookingUpdateOneRequiredWithoutPaymentInput {
  create: BookingCreateWithoutPaymentInput
  update: BookingUpdateWithoutPaymentDataInput
  upsert: BookingUpsertWithoutPaymentInput
  connect: BookingWhereUniqueInput
}

input BookingUpdateWithoutListingDataInput {
  bookee: UserUpdateOneRequiredInput
  occasionDate: DateTime
  location: LocationUpdateOneInput
  payment: PaymentUpdateOneWithoutBookingInput
  isFulfilled: Boolean
}

input BookingUpdateWithoutPaymentDataInput {
  bookee: UserUpdateOneRequiredInput
  listing: ListingUpdateOneRequiredWithoutBookingsInput
  occasionDate: DateTime
  location: LocationUpdateOneInput
  isFulfilled: Boolean
}

input BookingUpdateWithWhereUniqueWithoutListingInput {
  where: BookingWhereUniqueInput!
  data: BookingUpdateWithoutListingDataInput!
}

input BookingUpsertWithoutPaymentInput {
  update: BookingUpdateWithoutPaymentDataInput!
  create: BookingCreateWithoutPaymentInput!
}

input BookingUpsertWithWhereUniqueWithoutListingInput {
  where: BookingWhereUniqueInput!
  update: BookingUpdateWithoutListingDataInput!
  create: BookingCreateWithoutListingInput!
}

input BookingWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  bookee: UserWhereInput
  listing: ListingWhereInput
  occasionDate: DateTime
  occasionDate_not: DateTime
  occasionDate_in: [DateTime!]
  occasionDate_not_in: [DateTime!]
  occasionDate_lt: DateTime
  occasionDate_lte: DateTime
  occasionDate_gt: DateTime
  occasionDate_gte: DateTime
  location: LocationWhereInput
  payment: PaymentWhereInput
  isFulfilled: Boolean
  isFulfilled_not: Boolean
  AND: [BookingWhereInput!]
  OR: [BookingWhereInput!]
  NOT: [BookingWhereInput!]
}

input BookingWhereUniqueInput {
  id: ID
}

scalar DateTime

type Listing {
  id: ID!
  title: String!
  description: String!
  createdAt: DateTime!
  updatedAt: DateTime!
  maxGuests: Int!
  reviews(where: ReviewWhereInput, orderBy: ReviewOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Review!]
  vendor: Vendor!
  pricePerPlate: Int!
  views: Views
  bookings(where: BookingWhereInput, orderBy: BookingOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Booking!]
  photos(where: PictureWhereInput, orderBy: PictureOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Picture!]
}

type ListingConnection {
  pageInfo: PageInfo!
  edges: [ListingEdge]!
  aggregate: AggregateListing!
}

input ListingCreateInput {
  id: ID
  title: String!
  description: String!
  maxGuests: Int!
  reviews: ReviewCreateManyWithoutListingInput
  vendor: VendorCreateOneWithoutListingsInput!
  pricePerPlate: Int!
  views: ViewsCreateOneWithoutListingInput
  bookings: BookingCreateManyWithoutListingInput
  photos: PictureCreateManyWithoutListingInput
}

input ListingCreateManyInput {
  create: [ListingCreateInput!]
  connect: [ListingWhereUniqueInput!]
}

input ListingCreateManyWithoutVendorInput {
  create: [ListingCreateWithoutVendorInput!]
  connect: [ListingWhereUniqueInput!]
}

input ListingCreateOneWithoutBookingsInput {
  create: ListingCreateWithoutBookingsInput
  connect: ListingWhereUniqueInput
}

input ListingCreateOneWithoutPhotosInput {
  create: ListingCreateWithoutPhotosInput
  connect: ListingWhereUniqueInput
}

input ListingCreateOneWithoutReviewsInput {
  create: ListingCreateWithoutReviewsInput
  connect: ListingWhereUniqueInput
}

input ListingCreateOneWithoutViewsInput {
  create: ListingCreateWithoutViewsInput
  connect: ListingWhereUniqueInput
}

input ListingCreateWithoutBookingsInput {
  id: ID
  title: String!
  description: String!
  maxGuests: Int!
  reviews: ReviewCreateManyWithoutListingInput
  vendor: VendorCreateOneWithoutListingsInput!
  pricePerPlate: Int!
  views: ViewsCreateOneWithoutListingInput
  photos: PictureCreateManyWithoutListingInput
}

input ListingCreateWithoutPhotosInput {
  id: ID
  title: String!
  description: String!
  maxGuests: Int!
  reviews: ReviewCreateManyWithoutListingInput
  vendor: VendorCreateOneWithoutListingsInput!
  pricePerPlate: Int!
  views: ViewsCreateOneWithoutListingInput
  bookings: BookingCreateManyWithoutListingInput
}

input ListingCreateWithoutReviewsInput {
  id: ID
  title: String!
  description: String!
  maxGuests: Int!
  vendor: VendorCreateOneWithoutListingsInput!
  pricePerPlate: Int!
  views: ViewsCreateOneWithoutListingInput
  bookings: BookingCreateManyWithoutListingInput
  photos: PictureCreateManyWithoutListingInput
}

input ListingCreateWithoutVendorInput {
  id: ID
  title: String!
  description: String!
  maxGuests: Int!
  reviews: ReviewCreateManyWithoutListingInput
  pricePerPlate: Int!
  views: ViewsCreateOneWithoutListingInput
  bookings: BookingCreateManyWithoutListingInput
  photos: PictureCreateManyWithoutListingInput
}

input ListingCreateWithoutViewsInput {
  id: ID
  title: String!
  description: String!
  maxGuests: Int!
  reviews: ReviewCreateManyWithoutListingInput
  vendor: VendorCreateOneWithoutListingsInput!
  pricePerPlate: Int!
  bookings: BookingCreateManyWithoutListingInput
  photos: PictureCreateManyWithoutListingInput
}

type ListingEdge {
  node: Listing!
  cursor: String!
}

enum ListingOrderByInput {
  id_ASC
  id_DESC
  title_ASC
  title_DESC
  description_ASC
  description_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
  maxGuests_ASC
  maxGuests_DESC
  pricePerPlate_ASC
  pricePerPlate_DESC
}

type ListingPreviousValues {
  id: ID!
  title: String!
  description: String!
  createdAt: DateTime!
  updatedAt: DateTime!
  maxGuests: Int!
  pricePerPlate: Int!
}

input ListingScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  title: String
  title_not: String
  title_in: [String!]
  title_not_in: [String!]
  title_lt: String
  title_lte: String
  title_gt: String
  title_gte: String
  title_contains: String
  title_not_contains: String
  title_starts_with: String
  title_not_starts_with: String
  title_ends_with: String
  title_not_ends_with: String
  description: String
  description_not: String
  description_in: [String!]
  description_not_in: [String!]
  description_lt: String
  description_lte: String
  description_gt: String
  description_gte: String
  description_contains: String
  description_not_contains: String
  description_starts_with: String
  description_not_starts_with: String
  description_ends_with: String
  description_not_ends_with: String
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  maxGuests: Int
  maxGuests_not: Int
  maxGuests_in: [Int!]
  maxGuests_not_in: [Int!]
  maxGuests_lt: Int
  maxGuests_lte: Int
  maxGuests_gt: Int
  maxGuests_gte: Int
  pricePerPlate: Int
  pricePerPlate_not: Int
  pricePerPlate_in: [Int!]
  pricePerPlate_not_in: [Int!]
  pricePerPlate_lt: Int
  pricePerPlate_lte: Int
  pricePerPlate_gt: Int
  pricePerPlate_gte: Int
  AND: [ListingScalarWhereInput!]
  OR: [ListingScalarWhereInput!]
  NOT: [ListingScalarWhereInput!]
}

type ListingSubscriptionPayload {
  mutation: MutationType!
  node: Listing
  updatedFields: [String!]
  previousValues: ListingPreviousValues
}

input ListingSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: ListingWhereInput
  AND: [ListingSubscriptionWhereInput!]
  OR: [ListingSubscriptionWhereInput!]
  NOT: [ListingSubscriptionWhereInput!]
}

input ListingUpdateDataInput {
  title: String
  description: String
  maxGuests: Int
  reviews: ReviewUpdateManyWithoutListingInput
  vendor: VendorUpdateOneRequiredWithoutListingsInput
  pricePerPlate: Int
  views: ViewsUpdateOneWithoutListingInput
  bookings: BookingUpdateManyWithoutListingInput
  photos: PictureUpdateManyWithoutListingInput
}

input ListingUpdateInput {
  title: String
  description: String
  maxGuests: Int
  reviews: ReviewUpdateManyWithoutListingInput
  vendor: VendorUpdateOneRequiredWithoutListingsInput
  pricePerPlate: Int
  views: ViewsUpdateOneWithoutListingInput
  bookings: BookingUpdateManyWithoutListingInput
  photos: PictureUpdateManyWithoutListingInput
}

input ListingUpdateManyDataInput {
  title: String
  description: String
  maxGuests: Int
  pricePerPlate: Int
}

input ListingUpdateManyInput {
  create: [ListingCreateInput!]
  update: [ListingUpdateWithWhereUniqueNestedInput!]
  upsert: [ListingUpsertWithWhereUniqueNestedInput!]
  delete: [ListingWhereUniqueInput!]
  connect: [ListingWhereUniqueInput!]
  set: [ListingWhereUniqueInput!]
  disconnect: [ListingWhereUniqueInput!]
  deleteMany: [ListingScalarWhereInput!]
  updateMany: [ListingUpdateManyWithWhereNestedInput!]
}

input ListingUpdateManyMutationInput {
  title: String
  description: String
  maxGuests: Int
  pricePerPlate: Int
}

input ListingUpdateManyWithoutVendorInput {
  create: [ListingCreateWithoutVendorInput!]
  delete: [ListingWhereUniqueInput!]
  connect: [ListingWhereUniqueInput!]
  set: [ListingWhereUniqueInput!]
  disconnect: [ListingWhereUniqueInput!]
  update: [ListingUpdateWithWhereUniqueWithoutVendorInput!]
  upsert: [ListingUpsertWithWhereUniqueWithoutVendorInput!]
  deleteMany: [ListingScalarWhereInput!]
  updateMany: [ListingUpdateManyWithWhereNestedInput!]
}

input ListingUpdateManyWithWhereNestedInput {
  where: ListingScalarWhereInput!
  data: ListingUpdateManyDataInput!
}

input ListingUpdateOneRequiredWithoutBookingsInput {
  create: ListingCreateWithoutBookingsInput
  update: ListingUpdateWithoutBookingsDataInput
  upsert: ListingUpsertWithoutBookingsInput
  connect: ListingWhereUniqueInput
}

input ListingUpdateOneRequiredWithoutPhotosInput {
  create: ListingCreateWithoutPhotosInput
  update: ListingUpdateWithoutPhotosDataInput
  upsert: ListingUpsertWithoutPhotosInput
  connect: ListingWhereUniqueInput
}

input ListingUpdateOneRequiredWithoutReviewsInput {
  create: ListingCreateWithoutReviewsInput
  update: ListingUpdateWithoutReviewsDataInput
  upsert: ListingUpsertWithoutReviewsInput
  connect: ListingWhereUniqueInput
}

input ListingUpdateOneRequiredWithoutViewsInput {
  create: ListingCreateWithoutViewsInput
  update: ListingUpdateWithoutViewsDataInput
  upsert: ListingUpsertWithoutViewsInput
  connect: ListingWhereUniqueInput
}

input ListingUpdateWithoutBookingsDataInput {
  title: String
  description: String
  maxGuests: Int
  reviews: ReviewUpdateManyWithoutListingInput
  vendor: VendorUpdateOneRequiredWithoutListingsInput
  pricePerPlate: Int
  views: ViewsUpdateOneWithoutListingInput
  photos: PictureUpdateManyWithoutListingInput
}

input ListingUpdateWithoutPhotosDataInput {
  title: String
  description: String
  maxGuests: Int
  reviews: ReviewUpdateManyWithoutListingInput
  vendor: VendorUpdateOneRequiredWithoutListingsInput
  pricePerPlate: Int
  views: ViewsUpdateOneWithoutListingInput
  bookings: BookingUpdateManyWithoutListingInput
}

input ListingUpdateWithoutReviewsDataInput {
  title: String
  description: String
  maxGuests: Int
  vendor: VendorUpdateOneRequiredWithoutListingsInput
  pricePerPlate: Int
  views: ViewsUpdateOneWithoutListingInput
  bookings: BookingUpdateManyWithoutListingInput
  photos: PictureUpdateManyWithoutListingInput
}

input ListingUpdateWithoutVendorDataInput {
  title: String
  description: String
  maxGuests: Int
  reviews: ReviewUpdateManyWithoutListingInput
  pricePerPlate: Int
  views: ViewsUpdateOneWithoutListingInput
  bookings: BookingUpdateManyWithoutListingInput
  photos: PictureUpdateManyWithoutListingInput
}

input ListingUpdateWithoutViewsDataInput {
  title: String
  description: String
  maxGuests: Int
  reviews: ReviewUpdateManyWithoutListingInput
  vendor: VendorUpdateOneRequiredWithoutListingsInput
  pricePerPlate: Int
  bookings: BookingUpdateManyWithoutListingInput
  photos: PictureUpdateManyWithoutListingInput
}

input ListingUpdateWithWhereUniqueNestedInput {
  where: ListingWhereUniqueInput!
  data: ListingUpdateDataInput!
}

input ListingUpdateWithWhereUniqueWithoutVendorInput {
  where: ListingWhereUniqueInput!
  data: ListingUpdateWithoutVendorDataInput!
}

input ListingUpsertWithoutBookingsInput {
  update: ListingUpdateWithoutBookingsDataInput!
  create: ListingCreateWithoutBookingsInput!
}

input ListingUpsertWithoutPhotosInput {
  update: ListingUpdateWithoutPhotosDataInput!
  create: ListingCreateWithoutPhotosInput!
}

input ListingUpsertWithoutReviewsInput {
  update: ListingUpdateWithoutReviewsDataInput!
  create: ListingCreateWithoutReviewsInput!
}

input ListingUpsertWithoutViewsInput {
  update: ListingUpdateWithoutViewsDataInput!
  create: ListingCreateWithoutViewsInput!
}

input ListingUpsertWithWhereUniqueNestedInput {
  where: ListingWhereUniqueInput!
  update: ListingUpdateDataInput!
  create: ListingCreateInput!
}

input ListingUpsertWithWhereUniqueWithoutVendorInput {
  where: ListingWhereUniqueInput!
  update: ListingUpdateWithoutVendorDataInput!
  create: ListingCreateWithoutVendorInput!
}

input ListingWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  title: String
  title_not: String
  title_in: [String!]
  title_not_in: [String!]
  title_lt: String
  title_lte: String
  title_gt: String
  title_gte: String
  title_contains: String
  title_not_contains: String
  title_starts_with: String
  title_not_starts_with: String
  title_ends_with: String
  title_not_ends_with: String
  description: String
  description_not: String
  description_in: [String!]
  description_not_in: [String!]
  description_lt: String
  description_lte: String
  description_gt: String
  description_gte: String
  description_contains: String
  description_not_contains: String
  description_starts_with: String
  description_not_starts_with: String
  description_ends_with: String
  description_not_ends_with: String
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  maxGuests: Int
  maxGuests_not: Int
  maxGuests_in: [Int!]
  maxGuests_not_in: [Int!]
  maxGuests_lt: Int
  maxGuests_lte: Int
  maxGuests_gt: Int
  maxGuests_gte: Int
  reviews_every: ReviewWhereInput
  reviews_some: ReviewWhereInput
  reviews_none: ReviewWhereInput
  vendor: VendorWhereInput
  pricePerPlate: Int
  pricePerPlate_not: Int
  pricePerPlate_in: [Int!]
  pricePerPlate_not_in: [Int!]
  pricePerPlate_lt: Int
  pricePerPlate_lte: Int
  pricePerPlate_gt: Int
  pricePerPlate_gte: Int
  views: ViewsWhereInput
  bookings_every: BookingWhereInput
  bookings_some: BookingWhereInput
  bookings_none: BookingWhereInput
  photos_every: PictureWhereInput
  photos_some: PictureWhereInput
  photos_none: PictureWhereInput
  AND: [ListingWhereInput!]
  OR: [ListingWhereInput!]
  NOT: [ListingWhereInput!]
}

input ListingWhereUniqueInput {
  id: ID
}

type Location {
  id: ID!
  lat: Float!
  lng: Float!
  user: User
  directions: String!
}

type LocationConnection {
  pageInfo: PageInfo!
  edges: [LocationEdge]!
  aggregate: AggregateLocation!
}

input LocationCreateInput {
  id: ID
  lat: Float!
  lng: Float!
  user: UserCreateOneWithoutAddressInput
  directions: String!
}

input LocationCreateOneInput {
  create: LocationCreateInput
  connect: LocationWhereUniqueInput
}

input LocationCreateOneWithoutUserInput {
  create: LocationCreateWithoutUserInput
  connect: LocationWhereUniqueInput
}

input LocationCreateWithoutUserInput {
  id: ID
  lat: Float!
  lng: Float!
  directions: String!
}

type LocationEdge {
  node: Location!
  cursor: String!
}

enum LocationOrderByInput {
  id_ASC
  id_DESC
  lat_ASC
  lat_DESC
  lng_ASC
  lng_DESC
  directions_ASC
  directions_DESC
}

type LocationPreviousValues {
  id: ID!
  lat: Float!
  lng: Float!
  directions: String!
}

type LocationSubscriptionPayload {
  mutation: MutationType!
  node: Location
  updatedFields: [String!]
  previousValues: LocationPreviousValues
}

input LocationSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: LocationWhereInput
  AND: [LocationSubscriptionWhereInput!]
  OR: [LocationSubscriptionWhereInput!]
  NOT: [LocationSubscriptionWhereInput!]
}

input LocationUpdateDataInput {
  lat: Float
  lng: Float
  user: UserUpdateOneWithoutAddressInput
  directions: String
}

input LocationUpdateInput {
  lat: Float
  lng: Float
  user: UserUpdateOneWithoutAddressInput
  directions: String
}

input LocationUpdateManyMutationInput {
  lat: Float
  lng: Float
  directions: String
}

input LocationUpdateOneInput {
  create: LocationCreateInput
  update: LocationUpdateDataInput
  upsert: LocationUpsertNestedInput
  delete: Boolean
  disconnect: Boolean
  connect: LocationWhereUniqueInput
}

input LocationUpdateOneWithoutUserInput {
  create: LocationCreateWithoutUserInput
  update: LocationUpdateWithoutUserDataInput
  upsert: LocationUpsertWithoutUserInput
  delete: Boolean
  disconnect: Boolean
  connect: LocationWhereUniqueInput
}

input LocationUpdateWithoutUserDataInput {
  lat: Float
  lng: Float
  directions: String
}

input LocationUpsertNestedInput {
  update: LocationUpdateDataInput!
  create: LocationCreateInput!
}

input LocationUpsertWithoutUserInput {
  update: LocationUpdateWithoutUserDataInput!
  create: LocationCreateWithoutUserInput!
}

input LocationWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  lat: Float
  lat_not: Float
  lat_in: [Float!]
  lat_not_in: [Float!]
  lat_lt: Float
  lat_lte: Float
  lat_gt: Float
  lat_gte: Float
  lng: Float
  lng_not: Float
  lng_in: [Float!]
  lng_not_in: [Float!]
  lng_lt: Float
  lng_lte: Float
  lng_gt: Float
  lng_gte: Float
  user: UserWhereInput
  directions: String
  directions_not: String
  directions_in: [String!]
  directions_not_in: [String!]
  directions_lt: String
  directions_lte: String
  directions_gt: String
  directions_gte: String
  directions_contains: String
  directions_not_contains: String
  directions_starts_with: String
  directions_not_starts_with: String
  directions_ends_with: String
  directions_not_ends_with: String
  AND: [LocationWhereInput!]
  OR: [LocationWhereInput!]
  NOT: [LocationWhereInput!]
}

input LocationWhereUniqueInput {
  id: ID
}

scalar Long

type Mutation {
  createBooking(data: BookingCreateInput!): Booking!
  updateBooking(data: BookingUpdateInput!, where: BookingWhereUniqueInput!): Booking
  updateManyBookings(data: BookingUpdateManyMutationInput!, where: BookingWhereInput): BatchPayload!
  upsertBooking(where: BookingWhereUniqueInput!, create: BookingCreateInput!, update: BookingUpdateInput!): Booking!
  deleteBooking(where: BookingWhereUniqueInput!): Booking
  deleteManyBookings(where: BookingWhereInput): BatchPayload!
  createListing(data: ListingCreateInput!): Listing!
  updateListing(data: ListingUpdateInput!, where: ListingWhereUniqueInput!): Listing
  updateManyListings(data: ListingUpdateManyMutationInput!, where: ListingWhereInput): BatchPayload!
  upsertListing(where: ListingWhereUniqueInput!, create: ListingCreateInput!, update: ListingUpdateInput!): Listing!
  deleteListing(where: ListingWhereUniqueInput!): Listing
  deleteManyListings(where: ListingWhereInput): BatchPayload!
  createLocation(data: LocationCreateInput!): Location!
  updateLocation(data: LocationUpdateInput!, where: LocationWhereUniqueInput!): Location
  updateManyLocations(data: LocationUpdateManyMutationInput!, where: LocationWhereInput): BatchPayload!
  upsertLocation(where: LocationWhereUniqueInput!, create: LocationCreateInput!, update: LocationUpdateInput!): Location!
  deleteLocation(where: LocationWhereUniqueInput!): Location
  deleteManyLocations(where: LocationWhereInput): BatchPayload!
  createPayment(data: PaymentCreateInput!): Payment!
  updatePayment(data: PaymentUpdateInput!, where: PaymentWhereUniqueInput!): Payment
  updateManyPayments(data: PaymentUpdateManyMutationInput!, where: PaymentWhereInput): BatchPayload!
  upsertPayment(where: PaymentWhereUniqueInput!, create: PaymentCreateInput!, update: PaymentUpdateInput!): Payment!
  deletePayment(where: PaymentWhereUniqueInput!): Payment
  deleteManyPayments(where: PaymentWhereInput): BatchPayload!
  createPaymentAccount(data: PaymentAccountCreateInput!): PaymentAccount!
  updatePaymentAccount(data: PaymentAccountUpdateInput!, where: PaymentAccountWhereUniqueInput!): PaymentAccount
  updateManyPaymentAccounts(data: PaymentAccountUpdateManyMutationInput!, where: PaymentAccountWhereInput): BatchPayload!
  upsertPaymentAccount(where: PaymentAccountWhereUniqueInput!, create: PaymentAccountCreateInput!, update: PaymentAccountUpdateInput!): PaymentAccount!
  deletePaymentAccount(where: PaymentAccountWhereUniqueInput!): PaymentAccount
  deleteManyPaymentAccounts(where: PaymentAccountWhereInput): BatchPayload!
  createPicture(data: PictureCreateInput!): Picture!
  updatePicture(data: PictureUpdateInput!, where: PictureWhereUniqueInput!): Picture
  updateManyPictures(data: PictureUpdateManyMutationInput!, where: PictureWhereInput): BatchPayload!
  upsertPicture(where: PictureWhereUniqueInput!, create: PictureCreateInput!, update: PictureUpdateInput!): Picture!
  deletePicture(where: PictureWhereUniqueInput!): Picture
  deleteManyPictures(where: PictureWhereInput): BatchPayload!
  createReview(data: ReviewCreateInput!): Review!
  updateReview(data: ReviewUpdateInput!, where: ReviewWhereUniqueInput!): Review
  updateManyReviews(data: ReviewUpdateManyMutationInput!, where: ReviewWhereInput): BatchPayload!
  upsertReview(where: ReviewWhereUniqueInput!, create: ReviewCreateInput!, update: ReviewUpdateInput!): Review!
  deleteReview(where: ReviewWhereUniqueInput!): Review
  deleteManyReviews(where: ReviewWhereInput): BatchPayload!
  createUser(data: UserCreateInput!): User!
  updateUser(data: UserUpdateInput!, where: UserWhereUniqueInput!): User
  updateManyUsers(data: UserUpdateManyMutationInput!, where: UserWhereInput): BatchPayload!
  upsertUser(where: UserWhereUniqueInput!, create: UserCreateInput!, update: UserUpdateInput!): User!
  deleteUser(where: UserWhereUniqueInput!): User
  deleteManyUsers(where: UserWhereInput): BatchPayload!
  createVendor(data: VendorCreateInput!): Vendor!
  updateVendor(data: VendorUpdateInput!, where: VendorWhereUniqueInput!): Vendor
  updateManyVendors(data: VendorUpdateManyMutationInput!, where: VendorWhereInput): BatchPayload!
  upsertVendor(where: VendorWhereUniqueInput!, create: VendorCreateInput!, update: VendorUpdateInput!): Vendor!
  deleteVendor(where: VendorWhereUniqueInput!): Vendor
  deleteManyVendors(where: VendorWhereInput): BatchPayload!
  createViews(data: ViewsCreateInput!): Views!
  updateViews(data: ViewsUpdateInput!, where: ViewsWhereUniqueInput!): Views
  updateManyViewses(data: ViewsUpdateManyMutationInput!, where: ViewsWhereInput): BatchPayload!
  upsertViews(where: ViewsWhereUniqueInput!, create: ViewsCreateInput!, update: ViewsUpdateInput!): Views!
  deleteViews(where: ViewsWhereUniqueInput!): Views
  deleteManyViewses(where: ViewsWhereInput): BatchPayload!
  createsavedList(data: savedListCreateInput!): savedList!
  updatesavedList(data: savedListUpdateInput!, where: savedListWhereUniqueInput!): savedList
  upsertsavedList(where: savedListWhereUniqueInput!, create: savedListCreateInput!, update: savedListUpdateInput!): savedList!
  deletesavedList(where: savedListWhereUniqueInput!): savedList
  deleteManysavedLists(where: savedListWhereInput): BatchPayload!
}

enum MutationType {
  CREATED
  UPDATED
  DELETED
}

interface Node {
  id: ID!
}

type PageInfo {
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String
  endCursor: String
}

type Payment {
  id: ID!
  createdAt: DateTime!
  serviceFee: Float!
  price: Float!
  totalPrice: Float!
  booking: Booking!
  paymentMethod: PaymentAccount!
}

enum PAYMENT_PROVIDER {
  MPESA
  CREDIT_CARD
}

type PaymentAccount {
  id: ID!
  createdAt: DateTime!
  type: PAYMENT_PROVIDER
  user: User!
  payments(where: PaymentWhereInput, orderBy: PaymentOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Payment!]
}

type PaymentAccountConnection {
  pageInfo: PageInfo!
  edges: [PaymentAccountEdge]!
  aggregate: AggregatePaymentAccount!
}

input PaymentAccountCreateInput {
  id: ID
  type: PAYMENT_PROVIDER
  user: UserCreateOneInput!
  payments: PaymentCreateManyWithoutPaymentMethodInput
}

input PaymentAccountCreateOneWithoutPaymentsInput {
  create: PaymentAccountCreateWithoutPaymentsInput
  connect: PaymentAccountWhereUniqueInput
}

input PaymentAccountCreateWithoutPaymentsInput {
  id: ID
  type: PAYMENT_PROVIDER
  user: UserCreateOneInput!
}

type PaymentAccountEdge {
  node: PaymentAccount!
  cursor: String!
}

enum PaymentAccountOrderByInput {
  id_ASC
  id_DESC
  createdAt_ASC
  createdAt_DESC
  type_ASC
  type_DESC
}

type PaymentAccountPreviousValues {
  id: ID!
  createdAt: DateTime!
  type: PAYMENT_PROVIDER
}

type PaymentAccountSubscriptionPayload {
  mutation: MutationType!
  node: PaymentAccount
  updatedFields: [String!]
  previousValues: PaymentAccountPreviousValues
}

input PaymentAccountSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: PaymentAccountWhereInput
  AND: [PaymentAccountSubscriptionWhereInput!]
  OR: [PaymentAccountSubscriptionWhereInput!]
  NOT: [PaymentAccountSubscriptionWhereInput!]
}

input PaymentAccountUpdateInput {
  type: PAYMENT_PROVIDER
  user: UserUpdateOneRequiredInput
  payments: PaymentUpdateManyWithoutPaymentMethodInput
}

input PaymentAccountUpdateManyMutationInput {
  type: PAYMENT_PROVIDER
}

input PaymentAccountUpdateOneRequiredWithoutPaymentsInput {
  create: PaymentAccountCreateWithoutPaymentsInput
  update: PaymentAccountUpdateWithoutPaymentsDataInput
  upsert: PaymentAccountUpsertWithoutPaymentsInput
  connect: PaymentAccountWhereUniqueInput
}

input PaymentAccountUpdateWithoutPaymentsDataInput {
  type: PAYMENT_PROVIDER
  user: UserUpdateOneRequiredInput
}

input PaymentAccountUpsertWithoutPaymentsInput {
  update: PaymentAccountUpdateWithoutPaymentsDataInput!
  create: PaymentAccountCreateWithoutPaymentsInput!
}

input PaymentAccountWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  type: PAYMENT_PROVIDER
  type_not: PAYMENT_PROVIDER
  type_in: [PAYMENT_PROVIDER!]
  type_not_in: [PAYMENT_PROVIDER!]
  user: UserWhereInput
  payments_every: PaymentWhereInput
  payments_some: PaymentWhereInput
  payments_none: PaymentWhereInput
  AND: [PaymentAccountWhereInput!]
  OR: [PaymentAccountWhereInput!]
  NOT: [PaymentAccountWhereInput!]
}

input PaymentAccountWhereUniqueInput {
  id: ID
}

type PaymentConnection {
  pageInfo: PageInfo!
  edges: [PaymentEdge]!
  aggregate: AggregatePayment!
}

input PaymentCreateInput {
  id: ID
  serviceFee: Float!
  price: Float!
  totalPrice: Float!
  booking: BookingCreateOneWithoutPaymentInput!
  paymentMethod: PaymentAccountCreateOneWithoutPaymentsInput!
}

input PaymentCreateManyWithoutPaymentMethodInput {
  create: [PaymentCreateWithoutPaymentMethodInput!]
  connect: [PaymentWhereUniqueInput!]
}

input PaymentCreateOneWithoutBookingInput {
  create: PaymentCreateWithoutBookingInput
  connect: PaymentWhereUniqueInput
}

input PaymentCreateWithoutBookingInput {
  id: ID
  serviceFee: Float!
  price: Float!
  totalPrice: Float!
  paymentMethod: PaymentAccountCreateOneWithoutPaymentsInput!
}

input PaymentCreateWithoutPaymentMethodInput {
  id: ID
  serviceFee: Float!
  price: Float!
  totalPrice: Float!
  booking: BookingCreateOneWithoutPaymentInput!
}

type PaymentEdge {
  node: Payment!
  cursor: String!
}

enum PaymentOrderByInput {
  id_ASC
  id_DESC
  createdAt_ASC
  createdAt_DESC
  serviceFee_ASC
  serviceFee_DESC
  price_ASC
  price_DESC
  totalPrice_ASC
  totalPrice_DESC
}

type PaymentPreviousValues {
  id: ID!
  createdAt: DateTime!
  serviceFee: Float!
  price: Float!
  totalPrice: Float!
}

input PaymentScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  serviceFee: Float
  serviceFee_not: Float
  serviceFee_in: [Float!]
  serviceFee_not_in: [Float!]
  serviceFee_lt: Float
  serviceFee_lte: Float
  serviceFee_gt: Float
  serviceFee_gte: Float
  price: Float
  price_not: Float
  price_in: [Float!]
  price_not_in: [Float!]
  price_lt: Float
  price_lte: Float
  price_gt: Float
  price_gte: Float
  totalPrice: Float
  totalPrice_not: Float
  totalPrice_in: [Float!]
  totalPrice_not_in: [Float!]
  totalPrice_lt: Float
  totalPrice_lte: Float
  totalPrice_gt: Float
  totalPrice_gte: Float
  AND: [PaymentScalarWhereInput!]
  OR: [PaymentScalarWhereInput!]
  NOT: [PaymentScalarWhereInput!]
}

type PaymentSubscriptionPayload {
  mutation: MutationType!
  node: Payment
  updatedFields: [String!]
  previousValues: PaymentPreviousValues
}

input PaymentSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: PaymentWhereInput
  AND: [PaymentSubscriptionWhereInput!]
  OR: [PaymentSubscriptionWhereInput!]
  NOT: [PaymentSubscriptionWhereInput!]
}

input PaymentUpdateInput {
  serviceFee: Float
  price: Float
  totalPrice: Float
  booking: BookingUpdateOneRequiredWithoutPaymentInput
  paymentMethod: PaymentAccountUpdateOneRequiredWithoutPaymentsInput
}

input PaymentUpdateManyDataInput {
  serviceFee: Float
  price: Float
  totalPrice: Float
}

input PaymentUpdateManyMutationInput {
  serviceFee: Float
  price: Float
  totalPrice: Float
}

input PaymentUpdateManyWithoutPaymentMethodInput {
  create: [PaymentCreateWithoutPaymentMethodInput!]
  delete: [PaymentWhereUniqueInput!]
  connect: [PaymentWhereUniqueInput!]
  set: [PaymentWhereUniqueInput!]
  disconnect: [PaymentWhereUniqueInput!]
  update: [PaymentUpdateWithWhereUniqueWithoutPaymentMethodInput!]
  upsert: [PaymentUpsertWithWhereUniqueWithoutPaymentMethodInput!]
  deleteMany: [PaymentScalarWhereInput!]
  updateMany: [PaymentUpdateManyWithWhereNestedInput!]
}

input PaymentUpdateManyWithWhereNestedInput {
  where: PaymentScalarWhereInput!
  data: PaymentUpdateManyDataInput!
}

input PaymentUpdateOneWithoutBookingInput {
  create: PaymentCreateWithoutBookingInput
  update: PaymentUpdateWithoutBookingDataInput
  upsert: PaymentUpsertWithoutBookingInput
  delete: Boolean
  disconnect: Boolean
  connect: PaymentWhereUniqueInput
}

input PaymentUpdateWithoutBookingDataInput {
  serviceFee: Float
  price: Float
  totalPrice: Float
  paymentMethod: PaymentAccountUpdateOneRequiredWithoutPaymentsInput
}

input PaymentUpdateWithoutPaymentMethodDataInput {
  serviceFee: Float
  price: Float
  totalPrice: Float
  booking: BookingUpdateOneRequiredWithoutPaymentInput
}

input PaymentUpdateWithWhereUniqueWithoutPaymentMethodInput {
  where: PaymentWhereUniqueInput!
  data: PaymentUpdateWithoutPaymentMethodDataInput!
}

input PaymentUpsertWithoutBookingInput {
  update: PaymentUpdateWithoutBookingDataInput!
  create: PaymentCreateWithoutBookingInput!
}

input PaymentUpsertWithWhereUniqueWithoutPaymentMethodInput {
  where: PaymentWhereUniqueInput!
  update: PaymentUpdateWithoutPaymentMethodDataInput!
  create: PaymentCreateWithoutPaymentMethodInput!
}

input PaymentWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  serviceFee: Float
  serviceFee_not: Float
  serviceFee_in: [Float!]
  serviceFee_not_in: [Float!]
  serviceFee_lt: Float
  serviceFee_lte: Float
  serviceFee_gt: Float
  serviceFee_gte: Float
  price: Float
  price_not: Float
  price_in: [Float!]
  price_not_in: [Float!]
  price_lt: Float
  price_lte: Float
  price_gt: Float
  price_gte: Float
  totalPrice: Float
  totalPrice_not: Float
  totalPrice_in: [Float!]
  totalPrice_not_in: [Float!]
  totalPrice_lt: Float
  totalPrice_lte: Float
  totalPrice_gt: Float
  totalPrice_gte: Float
  booking: BookingWhereInput
  paymentMethod: PaymentAccountWhereInput
  AND: [PaymentWhereInput!]
  OR: [PaymentWhereInput!]
  NOT: [PaymentWhereInput!]
}

input PaymentWhereUniqueInput {
  id: ID
}

type Picture {
  id: ID!
  url: String!
  listing: Listing!
}

type PictureConnection {
  pageInfo: PageInfo!
  edges: [PictureEdge]!
  aggregate: AggregatePicture!
}

input PictureCreateInput {
  id: ID
  url: String!
  listing: ListingCreateOneWithoutPhotosInput!
}

input PictureCreateManyWithoutListingInput {
  create: [PictureCreateWithoutListingInput!]
  connect: [PictureWhereUniqueInput!]
}

input PictureCreateWithoutListingInput {
  id: ID
  url: String!
}

type PictureEdge {
  node: Picture!
  cursor: String!
}

enum PictureOrderByInput {
  id_ASC
  id_DESC
  url_ASC
  url_DESC
}

type PicturePreviousValues {
  id: ID!
  url: String!
}

input PictureScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  url: String
  url_not: String
  url_in: [String!]
  url_not_in: [String!]
  url_lt: String
  url_lte: String
  url_gt: String
  url_gte: String
  url_contains: String
  url_not_contains: String
  url_starts_with: String
  url_not_starts_with: String
  url_ends_with: String
  url_not_ends_with: String
  AND: [PictureScalarWhereInput!]
  OR: [PictureScalarWhereInput!]
  NOT: [PictureScalarWhereInput!]
}

type PictureSubscriptionPayload {
  mutation: MutationType!
  node: Picture
  updatedFields: [String!]
  previousValues: PicturePreviousValues
}

input PictureSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: PictureWhereInput
  AND: [PictureSubscriptionWhereInput!]
  OR: [PictureSubscriptionWhereInput!]
  NOT: [PictureSubscriptionWhereInput!]
}

input PictureUpdateInput {
  url: String
  listing: ListingUpdateOneRequiredWithoutPhotosInput
}

input PictureUpdateManyDataInput {
  url: String
}

input PictureUpdateManyMutationInput {
  url: String
}

input PictureUpdateManyWithoutListingInput {
  create: [PictureCreateWithoutListingInput!]
  delete: [PictureWhereUniqueInput!]
  connect: [PictureWhereUniqueInput!]
  set: [PictureWhereUniqueInput!]
  disconnect: [PictureWhereUniqueInput!]
  update: [PictureUpdateWithWhereUniqueWithoutListingInput!]
  upsert: [PictureUpsertWithWhereUniqueWithoutListingInput!]
  deleteMany: [PictureScalarWhereInput!]
  updateMany: [PictureUpdateManyWithWhereNestedInput!]
}

input PictureUpdateManyWithWhereNestedInput {
  where: PictureScalarWhereInput!
  data: PictureUpdateManyDataInput!
}

input PictureUpdateWithoutListingDataInput {
  url: String
}

input PictureUpdateWithWhereUniqueWithoutListingInput {
  where: PictureWhereUniqueInput!
  data: PictureUpdateWithoutListingDataInput!
}

input PictureUpsertWithWhereUniqueWithoutListingInput {
  where: PictureWhereUniqueInput!
  update: PictureUpdateWithoutListingDataInput!
  create: PictureCreateWithoutListingInput!
}

input PictureWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  url: String
  url_not: String
  url_in: [String!]
  url_not_in: [String!]
  url_lt: String
  url_lte: String
  url_gt: String
  url_gte: String
  url_contains: String
  url_not_contains: String
  url_starts_with: String
  url_not_starts_with: String
  url_ends_with: String
  url_not_ends_with: String
  listing: ListingWhereInput
  AND: [PictureWhereInput!]
  OR: [PictureWhereInput!]
  NOT: [PictureWhereInput!]
}

input PictureWhereUniqueInput {
  id: ID
}

type Query {
  booking(where: BookingWhereUniqueInput!): Booking
  bookings(where: BookingWhereInput, orderBy: BookingOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Booking]!
  bookingsConnection(where: BookingWhereInput, orderBy: BookingOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): BookingConnection!
  listing(where: ListingWhereUniqueInput!): Listing
  listings(where: ListingWhereInput, orderBy: ListingOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Listing]!
  listingsConnection(where: ListingWhereInput, orderBy: ListingOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): ListingConnection!
  location(where: LocationWhereUniqueInput!): Location
  locations(where: LocationWhereInput, orderBy: LocationOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Location]!
  locationsConnection(where: LocationWhereInput, orderBy: LocationOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): LocationConnection!
  payment(where: PaymentWhereUniqueInput!): Payment
  payments(where: PaymentWhereInput, orderBy: PaymentOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Payment]!
  paymentsConnection(where: PaymentWhereInput, orderBy: PaymentOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): PaymentConnection!
  paymentAccount(where: PaymentAccountWhereUniqueInput!): PaymentAccount
  paymentAccounts(where: PaymentAccountWhereInput, orderBy: PaymentAccountOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [PaymentAccount]!
  paymentAccountsConnection(where: PaymentAccountWhereInput, orderBy: PaymentAccountOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): PaymentAccountConnection!
  picture(where: PictureWhereUniqueInput!): Picture
  pictures(where: PictureWhereInput, orderBy: PictureOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Picture]!
  picturesConnection(where: PictureWhereInput, orderBy: PictureOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): PictureConnection!
  review(where: ReviewWhereUniqueInput!): Review
  reviews(where: ReviewWhereInput, orderBy: ReviewOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Review]!
  reviewsConnection(where: ReviewWhereInput, orderBy: ReviewOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): ReviewConnection!
  user(where: UserWhereUniqueInput!): User
  users(where: UserWhereInput, orderBy: UserOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [User]!
  usersConnection(where: UserWhereInput, orderBy: UserOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): UserConnection!
  vendor(where: VendorWhereUniqueInput!): Vendor
  vendors(where: VendorWhereInput, orderBy: VendorOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Vendor]!
  vendorsConnection(where: VendorWhereInput, orderBy: VendorOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): VendorConnection!
  views(where: ViewsWhereUniqueInput!): Views
  viewses(where: ViewsWhereInput, orderBy: ViewsOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Views]!
  viewsesConnection(where: ViewsWhereInput, orderBy: ViewsOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): ViewsConnection!
  savedList(where: savedListWhereUniqueInput!): savedList
  savedLists(where: savedListWhereInput, orderBy: savedListOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [savedList]!
  savedListsConnection(where: savedListWhereInput, orderBy: savedListOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): savedListConnection!
  node(id: ID!): Node
}

type Review {
  id: ID!
  createdAt: DateTime!
  title: String!
  comment: String!
  stars: Int!
  listing: Listing!
}

type ReviewConnection {
  pageInfo: PageInfo!
  edges: [ReviewEdge]!
  aggregate: AggregateReview!
}

input ReviewCreateInput {
  id: ID
  title: String!
  comment: String!
  stars: Int!
  listing: ListingCreateOneWithoutReviewsInput!
}

input ReviewCreateManyWithoutListingInput {
  create: [ReviewCreateWithoutListingInput!]
  connect: [ReviewWhereUniqueInput!]
}

input ReviewCreateWithoutListingInput {
  id: ID
  title: String!
  comment: String!
  stars: Int!
}

type ReviewEdge {
  node: Review!
  cursor: String!
}

enum ReviewOrderByInput {
  id_ASC
  id_DESC
  createdAt_ASC
  createdAt_DESC
  title_ASC
  title_DESC
  comment_ASC
  comment_DESC
  stars_ASC
  stars_DESC
}

type ReviewPreviousValues {
  id: ID!
  createdAt: DateTime!
  title: String!
  comment: String!
  stars: Int!
}

input ReviewScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  title: String
  title_not: String
  title_in: [String!]
  title_not_in: [String!]
  title_lt: String
  title_lte: String
  title_gt: String
  title_gte: String
  title_contains: String
  title_not_contains: String
  title_starts_with: String
  title_not_starts_with: String
  title_ends_with: String
  title_not_ends_with: String
  comment: String
  comment_not: String
  comment_in: [String!]
  comment_not_in: [String!]
  comment_lt: String
  comment_lte: String
  comment_gt: String
  comment_gte: String
  comment_contains: String
  comment_not_contains: String
  comment_starts_with: String
  comment_not_starts_with: String
  comment_ends_with: String
  comment_not_ends_with: String
  stars: Int
  stars_not: Int
  stars_in: [Int!]
  stars_not_in: [Int!]
  stars_lt: Int
  stars_lte: Int
  stars_gt: Int
  stars_gte: Int
  AND: [ReviewScalarWhereInput!]
  OR: [ReviewScalarWhereInput!]
  NOT: [ReviewScalarWhereInput!]
}

type ReviewSubscriptionPayload {
  mutation: MutationType!
  node: Review
  updatedFields: [String!]
  previousValues: ReviewPreviousValues
}

input ReviewSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: ReviewWhereInput
  AND: [ReviewSubscriptionWhereInput!]
  OR: [ReviewSubscriptionWhereInput!]
  NOT: [ReviewSubscriptionWhereInput!]
}

input ReviewUpdateInput {
  title: String
  comment: String
  stars: Int
  listing: ListingUpdateOneRequiredWithoutReviewsInput
}

input ReviewUpdateManyDataInput {
  title: String
  comment: String
  stars: Int
}

input ReviewUpdateManyMutationInput {
  title: String
  comment: String
  stars: Int
}

input ReviewUpdateManyWithoutListingInput {
  create: [ReviewCreateWithoutListingInput!]
  delete: [ReviewWhereUniqueInput!]
  connect: [ReviewWhereUniqueInput!]
  set: [ReviewWhereUniqueInput!]
  disconnect: [ReviewWhereUniqueInput!]
  update: [ReviewUpdateWithWhereUniqueWithoutListingInput!]
  upsert: [ReviewUpsertWithWhereUniqueWithoutListingInput!]
  deleteMany: [ReviewScalarWhereInput!]
  updateMany: [ReviewUpdateManyWithWhereNestedInput!]
}

input ReviewUpdateManyWithWhereNestedInput {
  where: ReviewScalarWhereInput!
  data: ReviewUpdateManyDataInput!
}

input ReviewUpdateWithoutListingDataInput {
  title: String
  comment: String
  stars: Int
}

input ReviewUpdateWithWhereUniqueWithoutListingInput {
  where: ReviewWhereUniqueInput!
  data: ReviewUpdateWithoutListingDataInput!
}

input ReviewUpsertWithWhereUniqueWithoutListingInput {
  where: ReviewWhereUniqueInput!
  update: ReviewUpdateWithoutListingDataInput!
  create: ReviewCreateWithoutListingInput!
}

input ReviewWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  title: String
  title_not: String
  title_in: [String!]
  title_not_in: [String!]
  title_lt: String
  title_lte: String
  title_gt: String
  title_gte: String
  title_contains: String
  title_not_contains: String
  title_starts_with: String
  title_not_starts_with: String
  title_ends_with: String
  title_not_ends_with: String
  comment: String
  comment_not: String
  comment_in: [String!]
  comment_not_in: [String!]
  comment_lt: String
  comment_lte: String
  comment_gt: String
  comment_gte: String
  comment_contains: String
  comment_not_contains: String
  comment_starts_with: String
  comment_not_starts_with: String
  comment_ends_with: String
  comment_not_ends_with: String
  stars: Int
  stars_not: Int
  stars_in: [Int!]
  stars_not_in: [Int!]
  stars_lt: Int
  stars_lte: Int
  stars_gt: Int
  stars_gte: Int
  listing: ListingWhereInput
  AND: [ReviewWhereInput!]
  OR: [ReviewWhereInput!]
  NOT: [ReviewWhereInput!]
}

input ReviewWhereUniqueInput {
  id: ID
}

type savedList {
  id: ID!
  listings(where: ListingWhereInput, orderBy: ListingOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Listing!]
}

type savedListConnection {
  pageInfo: PageInfo!
  edges: [savedListEdge]!
  aggregate: AggregatesavedList!
}

input savedListCreateInput {
  id: ID
  listings: ListingCreateManyInput
}

input savedListCreateOneInput {
  create: savedListCreateInput
  connect: savedListWhereUniqueInput
}

type savedListEdge {
  node: savedList!
  cursor: String!
}

enum savedListOrderByInput {
  id_ASC
  id_DESC
}

type savedListPreviousValues {
  id: ID!
}

type savedListSubscriptionPayload {
  mutation: MutationType!
  node: savedList
  updatedFields: [String!]
  previousValues: savedListPreviousValues
}

input savedListSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: savedListWhereInput
  AND: [savedListSubscriptionWhereInput!]
  OR: [savedListSubscriptionWhereInput!]
  NOT: [savedListSubscriptionWhereInput!]
}

input savedListUpdateDataInput {
  listings: ListingUpdateManyInput
}

input savedListUpdateInput {
  listings: ListingUpdateManyInput
}

input savedListUpdateOneInput {
  create: savedListCreateInput
  update: savedListUpdateDataInput
  upsert: savedListUpsertNestedInput
  delete: Boolean
  disconnect: Boolean
  connect: savedListWhereUniqueInput
}

input savedListUpsertNestedInput {
  update: savedListUpdateDataInput!
  create: savedListCreateInput!
}

input savedListWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  listings_every: ListingWhereInput
  listings_some: ListingWhereInput
  listings_none: ListingWhereInput
  AND: [savedListWhereInput!]
  OR: [savedListWhereInput!]
  NOT: [savedListWhereInput!]
}

input savedListWhereUniqueInput {
  id: ID
}

type Subscription {
  booking(where: BookingSubscriptionWhereInput): BookingSubscriptionPayload
  listing(where: ListingSubscriptionWhereInput): ListingSubscriptionPayload
  location(where: LocationSubscriptionWhereInput): LocationSubscriptionPayload
  payment(where: PaymentSubscriptionWhereInput): PaymentSubscriptionPayload
  paymentAccount(where: PaymentAccountSubscriptionWhereInput): PaymentAccountSubscriptionPayload
  picture(where: PictureSubscriptionWhereInput): PictureSubscriptionPayload
  review(where: ReviewSubscriptionWhereInput): ReviewSubscriptionPayload
  user(where: UserSubscriptionWhereInput): UserSubscriptionPayload
  vendor(where: VendorSubscriptionWhereInput): VendorSubscriptionPayload
  views(where: ViewsSubscriptionWhereInput): ViewsSubscriptionPayload
  savedList(where: savedListSubscriptionWhereInput): savedListSubscriptionPayload
}

type User {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  email: String!
  firstName: String!
  phone: String
  password: String!
  lastName: String!
  address: Location
  saved: savedList
  photoUrl: String
}

type UserConnection {
  pageInfo: PageInfo!
  edges: [UserEdge]!
  aggregate: AggregateUser!
}

input UserCreateInput {
  id: ID
  email: String!
  firstName: String!
  phone: String
  password: String!
  lastName: String!
  address: LocationCreateOneWithoutUserInput
  saved: savedListCreateOneInput
  photoUrl: String
}

input UserCreateOneInput {
  create: UserCreateInput
  connect: UserWhereUniqueInput
}

input UserCreateOneWithoutAddressInput {
  create: UserCreateWithoutAddressInput
  connect: UserWhereUniqueInput
}

input UserCreateWithoutAddressInput {
  id: ID
  email: String!
  firstName: String!
  phone: String
  password: String!
  lastName: String!
  saved: savedListCreateOneInput
  photoUrl: String
}

type UserEdge {
  node: User!
  cursor: String!
}

enum UserOrderByInput {
  id_ASC
  id_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
  email_ASC
  email_DESC
  firstName_ASC
  firstName_DESC
  phone_ASC
  phone_DESC
  password_ASC
  password_DESC
  lastName_ASC
  lastName_DESC
  photoUrl_ASC
  photoUrl_DESC
}

type UserPreviousValues {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  email: String!
  firstName: String!
  phone: String
  password: String!
  lastName: String!
  photoUrl: String
}

type UserSubscriptionPayload {
  mutation: MutationType!
  node: User
  updatedFields: [String!]
  previousValues: UserPreviousValues
}

input UserSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: UserWhereInput
  AND: [UserSubscriptionWhereInput!]
  OR: [UserSubscriptionWhereInput!]
  NOT: [UserSubscriptionWhereInput!]
}

input UserUpdateDataInput {
  email: String
  firstName: String
  phone: String
  password: String
  lastName: String
  address: LocationUpdateOneWithoutUserInput
  saved: savedListUpdateOneInput
  photoUrl: String
}

input UserUpdateInput {
  email: String
  firstName: String
  phone: String
  password: String
  lastName: String
  address: LocationUpdateOneWithoutUserInput
  saved: savedListUpdateOneInput
  photoUrl: String
}

input UserUpdateManyMutationInput {
  email: String
  firstName: String
  phone: String
  password: String
  lastName: String
  photoUrl: String
}

input UserUpdateOneRequiredInput {
  create: UserCreateInput
  update: UserUpdateDataInput
  upsert: UserUpsertNestedInput
  connect: UserWhereUniqueInput
}

input UserUpdateOneWithoutAddressInput {
  create: UserCreateWithoutAddressInput
  update: UserUpdateWithoutAddressDataInput
  upsert: UserUpsertWithoutAddressInput
  delete: Boolean
  disconnect: Boolean
  connect: UserWhereUniqueInput
}

input UserUpdateWithoutAddressDataInput {
  email: String
  firstName: String
  phone: String
  password: String
  lastName: String
  saved: savedListUpdateOneInput
  photoUrl: String
}

input UserUpsertNestedInput {
  update: UserUpdateDataInput!
  create: UserCreateInput!
}

input UserUpsertWithoutAddressInput {
  update: UserUpdateWithoutAddressDataInput!
  create: UserCreateWithoutAddressInput!
}

input UserWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  email: String
  email_not: String
  email_in: [String!]
  email_not_in: [String!]
  email_lt: String
  email_lte: String
  email_gt: String
  email_gte: String
  email_contains: String
  email_not_contains: String
  email_starts_with: String
  email_not_starts_with: String
  email_ends_with: String
  email_not_ends_with: String
  firstName: String
  firstName_not: String
  firstName_in: [String!]
  firstName_not_in: [String!]
  firstName_lt: String
  firstName_lte: String
  firstName_gt: String
  firstName_gte: String
  firstName_contains: String
  firstName_not_contains: String
  firstName_starts_with: String
  firstName_not_starts_with: String
  firstName_ends_with: String
  firstName_not_ends_with: String
  phone: String
  phone_not: String
  phone_in: [String!]
  phone_not_in: [String!]
  phone_lt: String
  phone_lte: String
  phone_gt: String
  phone_gte: String
  phone_contains: String
  phone_not_contains: String
  phone_starts_with: String
  phone_not_starts_with: String
  phone_ends_with: String
  phone_not_ends_with: String
  password: String
  password_not: String
  password_in: [String!]
  password_not_in: [String!]
  password_lt: String
  password_lte: String
  password_gt: String
  password_gte: String
  password_contains: String
  password_not_contains: String
  password_starts_with: String
  password_not_starts_with: String
  password_ends_with: String
  password_not_ends_with: String
  lastName: String
  lastName_not: String
  lastName_in: [String!]
  lastName_not_in: [String!]
  lastName_lt: String
  lastName_lte: String
  lastName_gt: String
  lastName_gte: String
  lastName_contains: String
  lastName_not_contains: String
  lastName_starts_with: String
  lastName_not_starts_with: String
  lastName_ends_with: String
  lastName_not_ends_with: String
  address: LocationWhereInput
  saved: savedListWhereInput
  photoUrl: String
  photoUrl_not: String
  photoUrl_in: [String!]
  photoUrl_not_in: [String!]
  photoUrl_lt: String
  photoUrl_lte: String
  photoUrl_gt: String
  photoUrl_gte: String
  photoUrl_contains: String
  photoUrl_not_contains: String
  photoUrl_starts_with: String
  photoUrl_not_starts_with: String
  photoUrl_ends_with: String
  photoUrl_not_ends_with: String
  AND: [UserWhereInput!]
  OR: [UserWhereInput!]
  NOT: [UserWhereInput!]
}

input UserWhereUniqueInput {
  id: ID
  email: String
}

type Vendor {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  firstName: String!
  lastName: String!
  email: String!
  password: String!
  phone: String!
  listings(where: ListingWhereInput, orderBy: ListingOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Listing!]
  vendorType: VENDOR_TYPE
}

enum VENDOR_TYPE {
  RESTAURANT
  INDEPENDENT
  BARS
}

type VendorConnection {
  pageInfo: PageInfo!
  edges: [VendorEdge]!
  aggregate: AggregateVendor!
}

input VendorCreateInput {
  id: ID
  firstName: String!
  lastName: String!
  email: String!
  password: String!
  phone: String!
  listings: ListingCreateManyWithoutVendorInput
  vendorType: VENDOR_TYPE
}

input VendorCreateOneWithoutListingsInput {
  create: VendorCreateWithoutListingsInput
  connect: VendorWhereUniqueInput
}

input VendorCreateWithoutListingsInput {
  id: ID
  firstName: String!
  lastName: String!
  email: String!
  password: String!
  phone: String!
  vendorType: VENDOR_TYPE
}

type VendorEdge {
  node: Vendor!
  cursor: String!
}

enum VendorOrderByInput {
  id_ASC
  id_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
  firstName_ASC
  firstName_DESC
  lastName_ASC
  lastName_DESC
  email_ASC
  email_DESC
  password_ASC
  password_DESC
  phone_ASC
  phone_DESC
  vendorType_ASC
  vendorType_DESC
}

type VendorPreviousValues {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  firstName: String!
  lastName: String!
  email: String!
  password: String!
  phone: String!
  vendorType: VENDOR_TYPE
}

type VendorSubscriptionPayload {
  mutation: MutationType!
  node: Vendor
  updatedFields: [String!]
  previousValues: VendorPreviousValues
}

input VendorSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: VendorWhereInput
  AND: [VendorSubscriptionWhereInput!]
  OR: [VendorSubscriptionWhereInput!]
  NOT: [VendorSubscriptionWhereInput!]
}

input VendorUpdateInput {
  firstName: String
  lastName: String
  email: String
  password: String
  phone: String
  listings: ListingUpdateManyWithoutVendorInput
  vendorType: VENDOR_TYPE
}

input VendorUpdateManyMutationInput {
  firstName: String
  lastName: String
  email: String
  password: String
  phone: String
  vendorType: VENDOR_TYPE
}

input VendorUpdateOneRequiredWithoutListingsInput {
  create: VendorCreateWithoutListingsInput
  update: VendorUpdateWithoutListingsDataInput
  upsert: VendorUpsertWithoutListingsInput
  connect: VendorWhereUniqueInput
}

input VendorUpdateWithoutListingsDataInput {
  firstName: String
  lastName: String
  email: String
  password: String
  phone: String
  vendorType: VENDOR_TYPE
}

input VendorUpsertWithoutListingsInput {
  update: VendorUpdateWithoutListingsDataInput!
  create: VendorCreateWithoutListingsInput!
}

input VendorWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  firstName: String
  firstName_not: String
  firstName_in: [String!]
  firstName_not_in: [String!]
  firstName_lt: String
  firstName_lte: String
  firstName_gt: String
  firstName_gte: String
  firstName_contains: String
  firstName_not_contains: String
  firstName_starts_with: String
  firstName_not_starts_with: String
  firstName_ends_with: String
  firstName_not_ends_with: String
  lastName: String
  lastName_not: String
  lastName_in: [String!]
  lastName_not_in: [String!]
  lastName_lt: String
  lastName_lte: String
  lastName_gt: String
  lastName_gte: String
  lastName_contains: String
  lastName_not_contains: String
  lastName_starts_with: String
  lastName_not_starts_with: String
  lastName_ends_with: String
  lastName_not_ends_with: String
  email: String
  email_not: String
  email_in: [String!]
  email_not_in: [String!]
  email_lt: String
  email_lte: String
  email_gt: String
  email_gte: String
  email_contains: String
  email_not_contains: String
  email_starts_with: String
  email_not_starts_with: String
  email_ends_with: String
  email_not_ends_with: String
  password: String
  password_not: String
  password_in: [String!]
  password_not_in: [String!]
  password_lt: String
  password_lte: String
  password_gt: String
  password_gte: String
  password_contains: String
  password_not_contains: String
  password_starts_with: String
  password_not_starts_with: String
  password_ends_with: String
  password_not_ends_with: String
  phone: String
  phone_not: String
  phone_in: [String!]
  phone_not_in: [String!]
  phone_lt: String
  phone_lte: String
  phone_gt: String
  phone_gte: String
  phone_contains: String
  phone_not_contains: String
  phone_starts_with: String
  phone_not_starts_with: String
  phone_ends_with: String
  phone_not_ends_with: String
  listings_every: ListingWhereInput
  listings_some: ListingWhereInput
  listings_none: ListingWhereInput
  vendorType: VENDOR_TYPE
  vendorType_not: VENDOR_TYPE
  vendorType_in: [VENDOR_TYPE!]
  vendorType_not_in: [VENDOR_TYPE!]
  AND: [VendorWhereInput!]
  OR: [VendorWhereInput!]
  NOT: [VendorWhereInput!]
}

input VendorWhereUniqueInput {
  id: ID
  email: String
}

type Views {
  id: ID!
  lastWeek: Int!
  listing: Listing!
}

type ViewsConnection {
  pageInfo: PageInfo!
  edges: [ViewsEdge]!
  aggregate: AggregateViews!
}

input ViewsCreateInput {
  id: ID
  lastWeek: Int!
  listing: ListingCreateOneWithoutViewsInput!
}

input ViewsCreateOneWithoutListingInput {
  create: ViewsCreateWithoutListingInput
  connect: ViewsWhereUniqueInput
}

input ViewsCreateWithoutListingInput {
  id: ID
  lastWeek: Int!
}

type ViewsEdge {
  node: Views!
  cursor: String!
}

enum ViewsOrderByInput {
  id_ASC
  id_DESC
  lastWeek_ASC
  lastWeek_DESC
}

type ViewsPreviousValues {
  id: ID!
  lastWeek: Int!
}

type ViewsSubscriptionPayload {
  mutation: MutationType!
  node: Views
  updatedFields: [String!]
  previousValues: ViewsPreviousValues
}

input ViewsSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: ViewsWhereInput
  AND: [ViewsSubscriptionWhereInput!]
  OR: [ViewsSubscriptionWhereInput!]
  NOT: [ViewsSubscriptionWhereInput!]
}

input ViewsUpdateInput {
  lastWeek: Int
  listing: ListingUpdateOneRequiredWithoutViewsInput
}

input ViewsUpdateManyMutationInput {
  lastWeek: Int
}

input ViewsUpdateOneWithoutListingInput {
  create: ViewsCreateWithoutListingInput
  update: ViewsUpdateWithoutListingDataInput
  upsert: ViewsUpsertWithoutListingInput
  delete: Boolean
  disconnect: Boolean
  connect: ViewsWhereUniqueInput
}

input ViewsUpdateWithoutListingDataInput {
  lastWeek: Int
}

input ViewsUpsertWithoutListingInput {
  update: ViewsUpdateWithoutListingDataInput!
  create: ViewsCreateWithoutListingInput!
}

input ViewsWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  lastWeek: Int
  lastWeek_not: Int
  lastWeek_in: [Int!]
  lastWeek_not_in: [Int!]
  lastWeek_lt: Int
  lastWeek_lte: Int
  lastWeek_gt: Int
  lastWeek_gte: Int
  listing: ListingWhereInput
  AND: [ViewsWhereInput!]
  OR: [ViewsWhereInput!]
  NOT: [ViewsWhereInput!]
}

input ViewsWhereUniqueInput {
  id: ID
}
`